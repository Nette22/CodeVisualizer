{"nodes" : [{"id" : 0, "x" : 958.6666870117188, "y" : 78.66667175292969, "width" : 131, "height" : 39, "nodename" : "HTML5 Platformer", "txt" : "HTML5%20Platformer"},{"id" : 1, "x" : 92, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "index.html", "txt" : "index.html"},{"id" : 2, "x" : 270.66668701171875, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "icons", "txt" : "icons"},{"id" : 3, "x" : 452, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "img", "txt" : "img"},{"id" : 4, "x" : 632, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "levels", "txt" : "levels"},{"id" : 5, "x" : 812, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "overlays", "txt" : "overlays"},{"id" : 6, "x" : 992, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "sounds", "txt" : "sounds"},{"id" : 7, "x" : 1176, "y" : 169.3333282470703, "width" : 131, "height" : 39, "nodename" : "src", "txt" : "src"},{"id" : 8, "x" : 168, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Backgrounds", "txt" : "Backgrounds"},{"id" : 9, "x" : 341.33331298828125, "y" : 289.33331298828125, "width" : 131, "height" : 39, "nodename" : "Tiles", "txt" : "Tiles"},{"id" : 10, "x" : 582.6666870117188, "y" : 288, "width" : 131, "height" : 39, "nodename" : "easeljs", "txt" : "easeljs"},{"id" : 11, "x" : 68, "y" : 398.66668701171875, "width" : 131, "height" : 39, "nodename" : "display", "txt" : "display"},{"id" : 12, "x" : 545.3333129882812, "y" : 393.33331298828125, "width" : 131, "height" : 39, "nodename" : "events", "txt" : "events"},{"id" : 13, "x" : 1045.3333740234375, "y" : 393.33331298828125, "width" : 131, "height" : 39, "nodename" : "geom", "txt" : "geom"},{"id" : 14, "x" : 1549.3333740234375, "y" : 393.33331298828125, "width" : 131, "height" : 39, "nodename" : "utils", "txt" : "utils"},{"id" : 25, "x" : 796, "y" : 432, "width" : 131, "height" : 39, "nodename" : "MouseEvent.js", "txt" : "MouseEvent.js"},{"id" : 26, "x" : 1301.3333740234375, "y" : 428, "width" : 131, "height" : 39, "nodename" : "Matrix2D.js", "txt" : "Matrix2D.js"},{"id" : 27, "x" : 1301.3333740234375, "y" : 476, "width" : 131, "height" : 39, "nodename" : "Point.js", "txt" : "Point.js"},{"id" : 28, "x" : 1301.3333740234375, "y" : 525.3333129882812, "width" : 131, "height" : 39, "nodename" : "Rectangle.js", "txt" : "Rectangle.js"},{"id" : 29, "x" : 1802.6666259765625, "y" : 425.33331298828125, "width" : 131, "height" : 39, "nodename" : "SpriteSheetUtils.js", "txt" : "SpriteSheetUtils.js"},{"id" : 30, "x" : 1804, "y" : 472, "width" : 131, "height" : 39, "nodename" : "Ticker.js", "txt" : "Ticker.js"},{"id" : 31, "x" : 1805.3333740234375, "y" : 518.6666870117188, "width" : 131, "height" : 39, "nodename" : "UID.js", "txt" : "UID.js"},{"id" : 32, "x" : 738.6666870117188, "y" : 288, "width" : 131, "height" : 39, "nodename" : "ContentManager.js", "txt" : "ContentManager.js"},{"id" : 33, "x" : 893.3333129882812, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Enemy.js", "txt" : "Enemy.js"},{"id" : 34, "x" : 1048, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Gem.js", "txt" : "Gem.js"},{"id" : 35, "x" : 1201.3333740234375, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Level.js", "txt" : "Level.js"},{"id" : 36, "x" : 1354.6666259765625, "y" : 288, "width" : 131, "height" : 39, "nodename" : "PlatformerGame.js", "txt" : "PlatformerGame.js"},{"id" : 37, "x" : 1508, "y" : 288, "width" : 131, "height" : 39, "nodename" : "PlatformerHelper.js", "txt" : "PlatformerHelper.js"},{"id" : 38, "x" : 1662.6666259765625, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Player.js", "txt" : "Player.js"},{"id" : 39, "x" : 1816, "y" : 288, "width" : 131, "height" : 39, "nodename" : "Tile.js", "txt" : "Tile.js"},{"id" : 40, "x" : 1969.3333740234375, "y" : 288, "width" : 131, "height" : 39, "nodename" : "XNARectangle.js", "txt" : "XNARectangle.js"},{"id" : 41, "x" : 314, "y" : 429, "width" : 126, "height" : 38, "nodename" : "Bitmap.js", "txt" : "/*\n* Bitmap by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* A Bitmap represents an Image, Canvas, or Video in the display list.\n* @class Bitmap\n* @extends DisplayObject\n* @constructor\n* @param {Image | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video to render to the display list.\n**/\nBitmap = function(image) {\n  this.initialize(image);\n}\nvar p = Bitmap.prototype = new DisplayObject();\n\n\t// public properties:\n\t/**\n\t* The image to render. This can be an Image, a Canvas, or a Video.\n\t* @property image\n\t* @type Image | HTMLCanvasElement | HTMLVideoElement\n\t**/\n\tp.image = null;\n\t\n\t/**\n\t* Whether or not the Bitmap should be draw to the canvas at whole pixel coordinates.\n\t* @property snapToPixel\n\t* @type Boolean\n\t* @default true\n\t**/\n\tp.snapToPixel = true;\n\t\n\t// constructor:\n\n\t/**\n\t* @property DisplayObject_initialize\n\t* @type Function\n    * @private\n\t**/\n\tp.DisplayObject_initialize = p.initialize;\n\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t*/\n\tp.initialize = function(image) {\n\t\tthis.DisplayObject_initialize();\n\t\tthis.image = image;\n\t}\n\t\n// public methods:\n\n\t/**\n\t* Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\treturn this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && this.image && (this.image.complete || this.image.getContext);\n\t}\n\n\t/**\n\t* @property DisplayObject_draw\n\t* @type Function\n\t* @private\n\t**/\n\tp.DisplayObject_draw = p.draw;\n\t\n\t/**\n\t* Draws the display object into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tctx.drawImage(this.image, 0, 0);\n\t\treturn true;\n\t}\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method cache\n\t**/\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method updateCache\n\t**/\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method uncache\n\t**/\n\t\n\t/**\n\t* Returns a clone of the Bitmap instance.\n\t* @method clone\n\t* @return {Bitmap} a clone of the Bitmap instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new Bitmap(this.image);\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Bitmap (name=\"+  this.name +\")]\";\n\t}\n\nwindow.Bitmap = Bitmap;\n}(window));"},{"id" : 42, "x" : 314, "y" : 481.5, "width" : 124, "height" : 38, "nodename" : "BitmapSequence.js", "txt" : "/*\n* BitmapSequence by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* Displays frames or sequences of frames from a sprite sheet image. A sprite sheet is a series of images \n* (usually animation frames) combined into a single image on a regular grid. For example, an animation \n* consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across by 2 high).\n* You can display individual frames, play sequential frames as an animation, and even sequence animations \n* together. See the SpriteSheet class for more information on setting up frames and animation.\n* @class BitmapSequence\n* @extends DisplayObject\n* @constructor\n* @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image, frame \n* dimensions, and frame data. See SpriteSheet for more information.\n**/\nBitmapSequence = function(spriteSheet) {\n  this.initialize(spriteSheet);\n}\nvar p = BitmapSequence.prototype = new DisplayObject();\n\n// public properties:\n\t\n\t/**\n\t* Specifies a function to call whenever any sequence reaches its end.\n\t* @property callback\n\t* @type Function\n\t**/\n\tp.callback = null;\n\t\n\t/**\n\t* The frame that will be drawn on the next tick. This can also be set, but it will not update the current\n\t* sequence, so it may result in unexpected behavior if you are using frameData.\n\t* @property currentFrame\n\t* @type Number\n\t* @default -1\n\t**/\n\tp.currentFrame = -1;\n\t\n\t/**\n\t* Returns the currently playing sequence when using frameData. READ-ONLY.\n\t* @property currentSequence\n\t* @type String\n\t* @final\n\t**/\n\tp.currentSequence = null; // READ-ONLY\n\n\t/**\n\t* Returns the last frame of the currently playing sequence when using frameData. READ-ONLY.\n\t* @property currentEndFrame\n\t* @type Number\n\t* @final\n\t**/\n\tp.currentEndFrame = null; // READ-ONLY\n\t\n\t/**\n\t* Returns the first frame of the currently playing sequence when using frameData. READ-ONLY.\n\t* @property currentStartFrame\n\t* @type Number\n\t* @final\n\t**/\n\tp.currentStartFrame = null; // READ-ONLY\n\t\n\t/**\n\t* Returns the name of the next sequence that will be played, or null if it will stop playing after the \n\t* current sequence. READ-ONLY.\n\t* @property nextSequence\n\t* @type String\n\t* @final\n\t**/\n\tp.nextSequence = null;\n\t\n\t/**\n\t* Prevents the animation from advancing each tick automatically. For example, you could create a sprite \n\t* sheet of icons, set paused to true, and display the appropriate icon by setting currentFrame.\n\t* @property paused\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp.paused = false;\n\t\n\t/**\n\t* The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame \n\t* data. See SpriteSheet for more information.\n\t* @property spriteSheet\n\t* @type SpriteSheet\n\t**/\n\tp.spriteSheet = null;\n\t\n\t/**\n\t* Whether or not the Bitmap should be draw to the canvas at whole pixel coordinates.\n\t* @property snapToPixel\n\t* @type Boolean\n\t* @default true\n\t**/\n\tp.snapToPixel = true;\n\t\n// constructor:\n\t/**\n\t* @property DisplayObject_initialize\n\t* @type Function\n\t* @private\n\t**/\n\tp.DisplayObject_initialize = p.initialize;\n\t\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t*/\n\tp.initialize = function(spriteSheet) {\n\t\tthis.DisplayObject_initialize();\n\t\tthis.spriteSheet = spriteSheet;\n\t}\n\t\n\t/**\n\t* Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\tvar image = this.spriteSheet ? this.spriteSheet.image : null;\n\t\treturn this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && image && this.currentFrame >= 0 && (image.complete || image.getContext);\n\t}\n\n\t/**\n\t* @property DisplayObject_draw\n\t* @type Function\n\t* @private\n\t**/\n\tp.DisplayObject_draw = p.draw;\n\t\n\t/**\n\t* Draws the display object into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\tvar image = this.spriteSheet.image;\n\t\tvar frameWidth = this.spriteSheet.frameWidth;\n\t\tvar frameHeight = this.spriteSheet.frameHeight;\n\t\tvar cols = image.width/frameWidth|0;\n\t\tvar rows = image.height/frameHeight|0;\n\t\t\n\t\tif (this.currentEndFrame != null) {\n\t\t\t// use sequencing.\n\t\t\tif (this.currentFrame > this.currentEndFrame) {\n\t\t\t\tif (this.nextSequence) {\n\t\t\t\t\tthis._goto(this.nextSequence);\n\t\t\t\t} else {\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tthis.currentFrame = this.currentEndFrame;\n\t\t\t\t}\n\t\t\t\tif (this.callback) { this.callback(this); }\n\t\t\t}\n\t\t} else {\n\t\t\t// use simple mode.\n\t\t\tvar ttlFrames = this.spriteSheet.totalFrames || cols*rows;\n\t\t\tif (this.currentFrame >= ttlFrames) {\n\t\t\t\tif (this.spriteSheet.loop) { this.currentFrame = 0; }\n\t\t\t\telse {\n\t\t\t\t\tthis.currentFrame = ttlFrames-1;\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t}\n\t\t\t\tif (this.callback) { this.callback(this); }\n\t\t\t}\n\t\t}\n\t\tif (this.currentFrame >= 0) {\n\t\t\tvar col = this.currentFrame%cols;\n\t\t\tvar row = this.currentFrame/cols|0;\n\t\t\tctx.drawImage(image, frameWidth*col, frameHeight*row, frameWidth, frameHeight, 0, 0, frameWidth, frameHeight);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Advances the currentFrame if paused is not true. This is called automatically when the Stage ticks.\n\t* @method tick\n\t**/\n\tp.tick = function() {\n\t\tif (this.currentFrame == -1 && this.spriteSheet.frameData) {\n\t\t\t// sequence data is set, but we haven't actually played a sequence yet:\n\t\t\tthis.paused = true;\n\t\t}\n\t\tif (this.paused) { return; }\n\t\tthis.currentFrame++;\n\t}\n\t\n\t//Note, the doc sections below document using the specified APIs (from DisplayObject)  from\n\t//Bitmap. This is why they have no method implementations.\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method cache\n\t**/\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method updateCache\n\t**/\n\t\n\t/**\n\t* Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.\n\t* You should not cache Bitmap instances as it can degrade performance.\n\t* @method uncache\n\t**/\n\t\n\t/**\n\t* Sets paused to false and plays the specified sequence name, named frame, or frame number.\n\t* @method gotoAndPlay\n\t* @param {String|Number} frameOrSequence The frame number or sequence that the playhead should move to\n\t* and begin playing.\n\t**/\n\tp.gotoAndPlay = function(frameOrSequence) {\n\t\tthis.paused = false;\n\t\tthis._goto(frameOrSequence);\n\t}\n\t\n\t/**\n\t* Sets paused to true and seeks to the specified sequence name, named frame, or frame number.\n\t* @method gotoAndStop\n\t* @param {String|Number} frameOrSequence The frame number or sequence that the playhead should move to\n\t* and stop.\n\t**/\n\tp.gotoAndStop = function(frameOrSequence) {\n\t\tthis.paused = true;\n\t\tthis._goto(frameOrSequence);\n\t}\n\t\n\t/**\n\t* Returns a clone of the Point instance.\n\t* @method clone\n\t* @return {Point} a clone of the Point instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new BitmapSequence(this.spriteSheet);\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[BitmapSequence (name=\"+  this.name +\")]\";\n\t}\n\t\n// private methods:\n\t/**\n\t* @property DisplayObject_cloneProps\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_cloneProps = p.cloneProps;\n\t\n\t/** \n\t* @method cloneProps\n\t* @param {Text} o\n\t* @protected\n\t**/\n\tp.cloneProps = function(o) {\n\t\tthis.DisplayObject_cloneProps(o);\n\t\to.callback = this.callback;\n\t\to.currentFrame = this.currentFrame;\n\t\to.currentStartFrame = this.currentStartFrame;\n\t\to.currentEndFrame = this.currentEndFrame;\n\t\to.currentSequence = this.currentSequence;\n\t\to.nextSequence = this.nextSequence;\n\t\to.paused = this.paused;\n\t\to.frameData = this.frameData;\n\t}\n\t\n\t/**\n\t* Moves the playhead to the specified frame number of sequence.\n\t* @method _goto\n\t* @param {String|Number} frameOrSequence The frame number of sequence that the playhead should move to.\n\t* @protected\n\t**/\n\tp._goto = function(frameOrSequence) {\n\t\tif (isNaN(frameOrSequence)) {\n\t\t\tif (frameOrSequence == this.currentSequence) {\n\t\t\t\tthis.currentFrame = this.currentStartFrame;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar data = this.spriteSheet.frameData[frameOrSequence];\n\t\t\tif (data instanceof Array) {\n\t\t\t\tthis.currentFrame = this.currentStartFrame = data[0];\n\t\t\t\tthis.currentSequence = frameOrSequence;\n\t\t\t\tthis.currentEndFrame = data[1];\n\t\t\t\tif (this.currentEndFrame == null) { this.currentEndFrame = this.currentStartFrame; }\n\t\t\t\tif (this.currentEndFrame == null) { this.currentEndFrame = this.currentFrame; }\n\t\t\t\tthis.nextSequence = data[2];\n\t\t\t\tif (this.nextSequence == null) { this.nextSequence = this.currentSequence; }\n\t\t\t\telse if (this.nextSequence == false) { this.nextSequence = null; }\n\t\t\t} else {\n\t\t\t\tthis.currentSequence = this.nextSequence = null;\n\t\t\t\tthis.currentEndFrame = this.currentFrame = this.currentStartFrame = data;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.currentSequence = this.nextSequence = this.currentEndFrame = null;\n\t\t\tthis.currentStartFrame = 0;\n\t\t\tthis.currentFrame = frameOrSequence;\n\t\t}\n\t}\n\nwindow.BitmapSequence = BitmapSequence;\n}(window));"},{"id" : 43, "x" : 313, "y" : 528, "width" : 124, "height" : 39, "nodename" : "Container.js", "txt" : "/*\n* Container by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* A Container is a nestable display lists that allows you to work with compound display elements. For \n* example you could group arm, leg, torso and head Bitmaps together into a Person Container, and \n* transform them as a group, while still being able to move the individual parts relative to each \n* other. Children of containers have their transform and alpha properties concatenated with their \n* parent Container. For example, a Shape with x=100 and alpha=0.5, placed in a Container with \n* x=50 and alpha=0.7 will be rendered to the canvas at x=150 and alpha=0.35. Containers have some \n* overhead, so you generally shouldn't create a Container to hold a single child.\n* @class Container\n* @extends DisplayObject\n* @constructor\n**/\nContainer = function() {\n  this.initialize();\n}\nvar p = Container.prototype = new DisplayObject();\n\n// public properties:\n\t/**\n\t* The array of children in the display list. You should usually use the child management methods, \n\t* rather than accessing this directly, but it is included for advanced users.\n\t* @property children\n\t* @type Array[DisplayObject]\n\t* @default null\n\t**/\n\tp.children = null;\n\n// constructor:\n\n\t/**\n\t* @property DisplayObject_initialize\n\t* @type Function\n\t* @private\n\t**/\n\tp.DisplayObject_initialize = p.initialize;\n\t\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t*/\n\tp.initialize = function() {\n\t\tthis.DisplayObject_initialize();\n\t\tthis.children = [];\n\t}\n\t\n// public methods:\n\n\t/**\n\t* Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\treturn this.visible && this.alpha > 0 && this.children.length && this.scaleX != 0 && this.scaleY != 0;\n\t}\n\n\t/**\n\t* @property DisplayObject_draw\n\t* @type Function\n\t* @private\n\t**/\n\tp.DisplayObject_draw = p.draw;\n\t\n\t/**\n\t* Draws the display object into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache, _mtx) {\n\t\tvar snap = Stage._snapToPixelEnabled;\n\t\tif (!_mtx) {\n\t\t\t_mtx = new Matrix2D();\n\t\t\t_mtx.appendProperties(this.alpha, this.shadow, this.compositeOperation);\n\t\t}\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tvar l = this.children.length;\n\t\t// this ensures we don't have issues with display list changes that occur during a draw:\n\t\tvar list = this.children.slice(0);\n\t\tfor (var i=0; i<l; i++) {\n\t\t\tvar child = list[i];\n\t\t\tif (child.tick) { child.tick(); }\n\t\t\tif (!child.isVisible()) { continue; }\n\t\t\t\n\t\t\tvar shadow = false;\n\t\t\tvar mtx = _mtx.clone();\n\t\t\tmtx.appendTransform(child.x, child.y, child.scaleX, child.scaleY, child.rotation, child.skewX, child.skewY, \n\t\t\t\t\t\t\t\t\tchild.regX, child.regY);\n\t\t\tmtx.appendProperties(child.alpha, child.shadow, child.compositeOperation);\n\n\t\t\tif (!(child instanceof Container)) {\n\t\t\t\tif (snap && child.snapToPixel && mtx.a == 1 && mtx.b == 0 && mtx.c == 0 && mtx.d == 1) {\n\t\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx+0.5|0, mtx.ty+0.5|0);\n\t\t\t\t} else {\n\t\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n\t\t\t\t}\n\t\t\t\tctx.globalAlpha = mtx.alpha;\n\t\t\t\tctx.globalCompositeOperation = mtx.compositeOperation || \"source-over\";\n\t\t\t\tif (shadow = mtx.shadow) { this.applyShadow(ctx, shadow); }\n\t\t\t}\n\t\t\tchild.draw(ctx, false, mtx);\n\t\t\tif (shadow) { this.applyShadow(ctx); }\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Adds a child to the top of the display list. You can also add multiple children, such as \"addChild(child1, child2, ...);\".\n\t* Returns the child that was added, or the last child if multiple children were added.\n\t* @method addChild\n\t* @param {DisplayObject} child The display object to add.\n\t* @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t**/\n\tp.addChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tfor (var i=0; i<l; i++) { this.addChild(arguments[i]); }\n\t\t\treturn arguments[l-1];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\t\n\t/**\n\t* Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and setting \n\t* its parent to this Container. You can also add multiple children, such as \"addChildAt(child1, child2, ..., index);\". The \n\t* index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list, you could use: \n\t* container.addChildAt(myShape, container.getChildIndex(otherShape)). This would also bump otherShape's index up by one. \n\t* Returns the last child that was added, or the last child if multiple children were added.\n\t* @method addChildAt\n\t* @param {DisplayObject} child The display object to add.\n\t* @param {Number} index The index to add the child at.\n\t* @return {DisplayObject} The child that was added, or the last child if multiple children were added.\n\t**/\n\tp.addChildAt = function(child, index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 2) {\n\t\t\tindex = arguments[i-1];\n\t\t\tfor (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], index+i); }\n\t\t\treturn arguments[l-2];\n\t\t}\n\t\tif (child.parent) { child.parent.removeChild(child); }\n\t\tchild.parent = this;\n\t\tthis.children.splice(index, 0, child);\n\t\treturn child;\n\t}\n\t\n\t/**\n\t* Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is already \n\t* known. You can also remove multiple children, such as \"removeChild(child1, child2, ...);\". Returns true if the child \n\t* (or children) was removed, or false if it was not in the display list.\n\t* @method removeChild\n\t* @param {DisplayObject} child The child to remove.\n\t* @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.\n\t**/\n\tp.removeChild = function(child) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }\n\t\t\treturn good;\n\t\t}\n\t\treturn this.removeChildAt(this.children.indexOf(child));\n\t}\n\t\n\t/**\n\t* Removes the child at the specified index from the display list, and sets its parent to null. You can also remove multiple\n\t* children, such as \"removeChildAt(2, 7, ...);\". Returns true if the child (or children) was removed, or false if any index\n\t* was out of range.\n\t* @param {Number} index The index of the child to remove.\n\t* @return true if the child (or children) was removed, or false if any index was out of range.\n\t**/\n\tp.removeChildAt = function(index) {\n\t\tvar l = arguments.length;\n\t\tif (l > 1) {\n\t\t\tvar a = [];\n\t\t\tfor (var i=0; i<l; i++) { a[i] = arguments[i]; }\n\t\t\ta.sort(function(a, b) { return b-a; })\n\t\t\tvar good = true;\n\t\t\tfor (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }\n\t\t\treturn good;\n\t\t}\n\t\tif (index < 0 || index > this.children.length-1) { return false; }\n\t\tvar child = this.children[index];\n\t\tif (child != null) { child.parent = null; }\n\t\tthis.children.splice(index, 1);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Removes all children from the display list.\n\t* @method removeAllChildren\n\t**/\n\tp.removeAllChildren = function() {\n\t\twhile (this.children.length) { this.removeChildAt(0); }\n\t}\n\t\n\t/**\n\t* Returns the child at the specified index.\n\t* @method getChildAt\n\t* @param {Number} index The index of the child to return.\n\t* @return {DisplayObject} The child at the specified index.\n\t**/\n\tp.getChildAt = function(index) {\n\t\treturn this.children[index];\n\t}\n\t\n\t/**\n\t* Performs an array sort operation on the child list.\n\t* @method sortChildren\n\t* @param {Function} sortFunction the function to use to sort the child list. See javascript's Array.sort documentation \n\t* for details.\n\t**/\n\tp.sortChildren = function(sortFunction) {\n\t\tthis.children.sort(sortFunction);\n\t}\n\t\n\t/**\n\t* Returns the index of the specified child in the display list, or -1 if it is not in the display list.\n\t* @method getChildIndex\n\t* @param {DisplayObject} child The child to return the index of.\n\t* @return {Number} The index of the specified child. -1 if the child is not found.\n\t**/\n\tp.getChildIndex = function(child) {\n\t\treturn this.children.indexOf(child);\n\t}\n\t\n\t/**\n\t* Returns the number of children in the display list.\n\t* @method getNumChildren\n\t* @return {Number} The number of children in the display list.\n\t**/\n\tp.getNumChildren = function() {\n\t\treturn this.children.length;\n\t}\n\t\n\t/**\n\t* Returns true if the specified display object either is this container or is a descendent.\n\t* (child, grandchild, etc) of this container.\n\t* @method contains\n\t* @param {DisplayObject} child The DisplayObject to be checked.\n\t* @return {Boolean} true if the specified display object either is this container or is a descendent.\n\t**/\n\tp.contains = function(child) {\n\t\twhile (child) {\n\t\t\tif (child == this) { return true; }\n\t\t\tchild = child.parent;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t* Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the specified \n\t* position). This ignores the alpha, shadow and compositeOperation of the display object, and all transform properties \n\t* including regX/Y.\n\t* @method hitTest\n\t* @param x The x position to check in the display object's local coordinates.\n\t* @param y The y position to check in the display object's local coordinates.\n\t* @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified \n\t* coordinates.\n\t**/\n\tp.hitTest = function(x, y) {\n\t\t// TODO: optimize to use the fast cache check where possible.\n\t\treturn (this.getObjectUnderPoint(x, y) != null);\n\t}\n\n\t/**\n\t* Returns an array of all display objects under the specified coordinates that are in this container's display list. \n\t* This routine ignores any display objects with mouseEnabled set to false. The array will be sorted in order of visual \n\t* depth, with the top-most display object at index 0. This uses shape based hit detection, and can be an expensive operation \n\t* to run, so it is best to use it carefully. For example, if testing for objects under the mouse, test on tick (instead of on \n\t* mousemove), and only if the mouse's position has changed.\n\t* @method getObjectsUnderPoint\n\t* @param {Number} x The x position in the container to test.\n\t* @param {Number} y The y position in the container to test.\n\t* @return {Array[DisplayObject]} An Array of DisplayObjects under the specified coordinates.\n\t**/\n\tp.getObjectsUnderPoint = function(x, y) {\n\t\tvar arr = [];\n\t\tvar pt = this.localToGlobal(x, y);\n\t\tthis._getObjectsUnderPoint(pt.x, pt.y, arr);\n\t\treturn arr;\n\t}\n\n\t/**\n\t* Similar to getObjectsUnderPoint(), but returns only the top-most display object. This runs significantly faster than \n\t* getObjectsUnderPoint(), but is still an expensive operation. See getObjectsUnderPoint() for more information.\n\t* @method getObjectUnderPoint\n\t* @param {Number} x The x position in the container to test.\n\t* @param {Number} y The y position in the container to test.\n\t* @return {DisplayObject} The top-most display object under the specified coordinates.\n\t**/\n\tp.getObjectUnderPoint = function(x, y) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn this._getObjectsUnderPoint(pt.x, pt.y);\n\t}\n\t\n\t/**\n\t* Returns a clone of this Container. Some properties that are specific to this instance's current context are reverted to\n\t* their defaults (for example .parent).\n\t* @param {Boolean} recursive If true, all of the descendants of this container will be cloned recursively. If false, the \n\t* properties of the container will be cloned, but the new instance will not have any children.\n\t* @return {Container} A clone of the current Container instance.\n\t**/\n\tp.clone = function(recursive) {\n\t\tvar o = new Container();\n\t\tthis.cloneProps(o);\n\t\tif (recursive) {\n\t\t\tvar arr = o.children = [];\n\t\t\tfor (var i=0, l=this.children.length; i<l; i++) {\n\t\t\t\tarr.push(this.children[i].clone(recursive));\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Container (name=\"+  this.name +\")]\";\n\t}\n\t\n// private properties:\n\t/** \n\t* @method _getObjectsUnderPoint\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Array} arr\n\t* @param {Number} mouseEvents A bitmask indicating which mouseEvent types to look for. Bit 1 specifies onPress & \n\t* onClick, bit 2 specifies it should look for onMouseOver and onMouseOut. This implementation may change.\n\t* @return {Array[DisplayObject]}\n\t* @protected\n\t**/\n\tp._getObjectsUnderPoint = function(x, y, arr, mouseEvents) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tvar canvas = DisplayObject._hitTestCanvas;\n\t\tvar mtx = DisplayObject._workingMatrix;\n\t\tvar hasHandler = (mouseEvents&1 && (this.onPress || this.onClick)) || (mouseEvents&2 && \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(this.onMouseOver || this.onMouseOut));\n\n\t\t// if we have a cache handy, we can use it to do a quick check:\n\t\tif (this.cacheCanvas) {\n\t\t\tthis.getConcatenatedMatrix(mtx);\n\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\tctx.globalAlpha = mtx.alpha;\n\t\t\tthis.draw(ctx);\n\t\t\tif (this._testHit(ctx)) {\n\t\t\t\tcanvas.width = 0;\n\t\t\t\tcanvas.width = 1;\n\t\t\t\tif (hasHandler) { return this; }\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// draw children one at a time, and check if we get a hit:\n\t\tvar l = this.children.length;\n\t\tfor (var i=l-1; i>=0; i--) {\n\t\t\tvar child = this.children[i];\n\t\t\tif (!child.isVisible() || !child.mouseEnabled) { continue; }\n\t\t\t\n\t\t\tif (child instanceof Container) {\n\t\t\t\tvar result;\n\t\t\t\tif (hasHandler) {\n\t\t\t\t\t// only concerned about the first hit, because this container is going to claim it anyway:\n\t\t\t\t\tresult = child._getObjectsUnderPoint(x, y);\n\t\t\t\t\tif (result) { return this; }\n\t\t\t\t} else {\n\t\t\t\t\tresult = child._getObjectsUnderPoint(x, y, arr, mouseEvents);\n\t\t\t\t\tif (!arr && result) { return result; }\n\t\t\t\t}\n\t\t\t} else if (!mouseEvents || hasHandler || (mouseEvents&1 && (child.onPress || child.onClick)) || \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(mouseEvents&2 && (child.onMouseOver || child.onMouseOut))) {\n\t\t\t\tchild.getConcatenatedMatrix(mtx);\n\t\t\t\tctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);\n\t\t\t\tctx.globalAlpha = mtx.alpha;\n\t\t\t\tchild.draw(ctx);\n\t\t\t\tif (!this._testHit(ctx)) { continue; }\n\t\t\t\tcanvas.width = 0;\n\t\t\t\tcanvas.width = 1;\n\t\t\t\tif (hasHandler) { return this; }\n\t\t\t\telse if (arr) { arr.push(child); }\n\t\t\t\telse { return child; }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\nwindow.Container = Container;\n}(window));"},{"id" : 44, "x" : 310, "y" : 577, "width" : 126, "height" : 41, "nodename" : "DisplayObject.js", "txt" : "/*\n* DisplayObject by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as \n* Sprite, Bitmap, and Shape. DisplayObject is the base class for all display classes in the CanvasDisplay library. \n* It defines the core properties and methods that are shared between all display objects.\n* @class DisplayObject\n* @constructor\n**/\nDisplayObject = function() {\n  this.initialize();\n}\nvar p = DisplayObject.prototype;\n\n/**\n* Suppresses errors generated when using features like hitTest, onPress/onClick, and getObjectsUnderPoint with cross \n* domain content\n* @property suppressCrossDomainErrors\n* @static\n* @type Boolean\n* @default false\n**/\nDisplayObject.suppressCrossDomainErrors = false;\n\n/**\n* @property _hitTestCanvas\n* @type HTMLCanvasElement\n* @static\n* @protected\n**/\nDisplayObject._hitTestCanvas = document.createElement(\"canvas\");\nDisplayObject._hitTestCanvas.width = DisplayObject._hitTestCanvas.height = 1;\n\n/**\n* @property _hitTestContext\n* @type CanvasRenderingContext2D\n* @static\n* @protected\n**/\nDisplayObject._hitTestContext = DisplayObject._hitTestCanvas.getContext(\"2d\");\n\n/**\n* @property _workingMatrix\n* @type Matrix2D\n* @static\n* @protected\n**/\nDisplayObject._workingMatrix = new Matrix2D();\n\n\n\t/** \n\t* The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.\n\t* @property alpha\n\t* @type Number\n\t* @default 1\n\t**/\n\tp.alpha = 1;\n\t\n\t/**\n\t* If a cache is active, this returns the canvas that holds the cached version of this display object. See cache()\n\t* for more information. READ-ONLY.\n\t* @property cacheCanvas\n\t* @type HTMLCanvasElement\n\t* @default null\n\t**/\n\tp.cacheCanvas = null;\n\t\n\t/**\n\t* Unique ID for this display object. Makes display objects easier for some uses.\n\t* @property id\n\t* @type Number\n\t* @default -1\n\t**/\n\tp.id = -1;\n\t\n\t/**\n\t* Indicates whether to include this object when running Stage.getObjectsUnderPoint(). Setting this to true for \n\t* Sprites will cause the Sprite to be returned (not its children) regardless of whether it's mouseChildren property \n\t* is true.\n\t* @property mouseEnabled\n\t* @type Boolean\n\t* @default true\n\t**/\n\tp.mouseEnabled = true;\n\t\n\t/**\n\t* An optional name for this display object. Included in toString(). Useful for debugging.\n\t* @property name\n\t* @type String\n\t* @default null\n\t**/\n\tp.name = null;\n\t\n\t/**\n\t* A reference to the Sprite or Stage object that contains this display object, or null if it has not been added to \n\t* one. READ-ONLY.\n\t* @property parent\n\t* @final\n\t* @type DisplayObject\n\t* @default null\n\t**/\n\tp.parent = null;\n\t\n\t/**\n\t* The x offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around\n\t* it's center, you would set regX and regY to 50.\n\t* @property regX\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.regX = 0;\n\t\n\t/**\n\t* The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around\n\t* it's center, you would set regX and regY to 50.\n\t* @property regY\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.regY = 0;\n\t\n\t/**\n\t* The rotation in degrees for this display object.\n\t* @property rotation\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.rotation = 0;\n\t\n\t/**\n\t* The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display\n\t* object to twice it's nominal width.\n\t* @property scaleX\n\t* @type Number\n\t* @default 1\n\t**/\n\tp.scaleX = 1;\n\t\n\t/**\n\t* The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display\n\t* object to half it's nominal height.\n\t* @property scaleY\n\t* @type Number\n\t* @default 1\n\t**/\n\tp.scaleY = 1;\n\t\n\t/**\n\t* The factor to skew this display object horizontally.\n\t* @property skewX\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.skewX = 0;\n\t\n\t/**\n\t* The factor to skew this display object vertically.\n\t* @property skewY\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.skewY = 0;\n\t\n\t/**\n\t* A shadow object that defines the shadow to render on this display object. Set to null to remove a shadow. If \n\t* null, this property is inherited from the parent container.\n\t* @property shadow\n\t* @type Shadow\n\t* @default null\n\t**/\n\tp.shadow = null;\n\t\n\t/**\n\t* Indicates whether this display object should be rendered to the canvas and included when running\n\t* Stage.getObjectsUnderPoint().\n\t* @property visible\n\t* @type Boolean\n\t* @default true\n\t**/\n\tp.visible = true;\n\t\n\t/**\n\t* The x (horizontal) position of the display object, relative to its parent.\n\t* @property x\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.x = 0;\n\t\n\t/** The y (vertical) position of the display object, relative to its parent.\n\t* @property y\n\t* @type Number\n\t* @default 0\n\t**/\n\tp.y = 0;\n\t\n\t/**\n\t* The composite operation indicates how the pixels of this display object will be composited with the elements \n\t* behind it. If null, this property is inherited from the parent container. For more information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t* whatwg spec on compositing</a>.\n\t* @property compositeOperation\n\t* @type String\n\t* @default null\n\t**/\n\tp.compositeOperation = null;\n\t\n\t/**\n\t* Indicates whether the display object should have it's x & y position rounded prior to drawing it to stage. \n\t* This only applies if the enclosing stage has snapPixelsEnabled set to true, and the display object's composite \n\t* transform does not include any scaling, rotation, or skewing. The snapToPixel property is true by default for \n\t* Bitmap and BitmapSequence instances, and false for all other display objects.\n\t* @property snapToPixel\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp.snapToPixel = false;\n\t\n\t/**\n\t* The onPress callback is called when the user presses down on their mouse over this display object. The handler \n\t* is passed a single param containing the corresponding MouseEvent instance. You can subscribe to the onMouseMove\n\t* and onMouseUp callbacks of the event object to receive these events until the user releases the mouse button. \n\t* If an onPress handler is set on a container, it will receive the event if any of its children are clicked.\n\t* @event onPress\n\t* @param {MouseEvent} event MouseEvent with information about the event.\n\t**/\n\tp.onPress = null;\n\t\n\t/**\n\t* The onClick callback is called when the user presses down on and then releases the mouse button over this \n\t* display object. The handler is passed a single param containing the corresponding MouseEvent instance. If an \n\t* onClick handler is set on a container, it will receive the event if any of its children are clicked.\n\t* @event onClick\n\t* @param {MouseEvent} event MouseEvent with information about the event.\n\t**/\n\tp.onClick = null;\n\t\n\t/**\n\t* The onMouseOver callback is called when the user rolls over the display object. You must enable this event using \n\t* stage.enableMouseOver(). The handler is passed a single param containing the corresponding MouseEvent instance.\n\t* @event onMouseOver\n\t* @param {MouseEvent} event MouseEvent with information about the event.\n\t**/\n\tp.onMouseOver = null;\n\t\n\t/**\n\t* The onMouseOut callback is called when the user rolls off of the display object. You must enable this event using\n\t* stage.enableMouseOver(). The handler is passed a single param containing the corresponding MouseEvent instance.\n\t* @event onMouseOut\n\t* @param {MouseEvent} event MouseEvent with information about the event.\n\t**/\n\tp.onMouseOut = null;\n\t\n// private properties:\n\n\t/**\n\t* @property _cacheOffsetX\n\t* @protected\n\t* @type Number\n\t* @default 0\n\t**/\n\tp._cacheOffsetX = 0;\n\t\n\t/**\n\t* @property _cacheOffsetY\n\t* @protected\n\t* @type Number\n\t* @default 0\n\t**/\n\tp._cacheOffsetY = 0;\n\t\n\t/**\n\t* @property _cacheDraw\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp._cacheDraw = false;\n\t\n\t/**\n\t* @property _activeContext\n\t* @protected\n\t* @type CanvasRenderingContext2D\n\t* @default null\n\t**/\n\tp._activeContext = null;\n\t\n\t/**\n\t* @property _restoreContext\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp._restoreContext = false;\n\t\n\t/**\n\t* @property _revertShadow\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp._revertShadow = false;\n\t\n\t/**\n\t* @property _revertX\n\t* @protected\n\t* @type Number\n\t* @default 0\n\t**/\n\tp._revertX = 0;\n\t\n\t/**\n\t* @property _revertY\n\t* @protected\n\t* @type Number\n\t* @default 0\n\t**/\n\tp._revertY = 0;\n\t\n\t/**\n\t* @property _revertAlpha\n\t* @protected\n\t* @type Number\n\t* @default 1\n\t**/\n\tp._revertAlpha = 1;\n\t\n// constructor:\n\t// separated so it can be easily addressed in subclasses:\n\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t*/\n\tp.initialize = function() {\n\t\tthis.id = UID.get();\n\t\tthis.children = [];\n\t}\n\t\n// public methods:\n\t/**\n\t* Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\treturn this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0;\n\t}\n\t\n\t/**\n\t* Draws the display object into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (ignoreCache || !this.cacheCanvas) { return false; }\n\t\tctx.translate(this._cacheOffsetX, this._cacheOffsetY);\n\t\tctx.drawImage(this.cacheCanvas, 0, 0);\n\t\tctx.translate(-this._cacheOffsetX, -this._cacheOffsetY);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Draws the display object into a new canvas, which is then used for subsequent draws. For complex content \n\t* that does not change frequently (ex. a Sprite with many children that do not move, or a complex vector Shape),\n\t* this can provide for much faster rendering because the content does not need to be re-rendered each tick. The \n\t* cached display object can be moved, rotated, faded, etc freely, however if it's content changes, you must manually\n\t* update the cache by calling updateCache() or cache() again. You must specify the cache area via the x, y, w, \n\t* and h parameters. This defines the rectangle that will be rendered and cached using this display object's \n\t* coordinates. For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25, you could call \n\t* myShape.cache(-25, -25, 50, 50) to cache the full shape.\n\t* @method cache\n\t* @param {Number} x The x coordinate origin for the cache region.\n\t* @param {Number} y The y coordinate origin for the cache region.\n\t* @param {Number} width The width of the cache region.\n\t* @param {Number} height The height of the cache region.\n\t**/\n\tp.cache = function(x, y, width, height) {\n\t\t// draw to canvas.\n\t\tvar ctx;\n\t\tif (this.cacheCanvas == null) { this.cacheCanvas = document.createElement(\"canvas\"); }\n\t\tctx = this.cacheCanvas.getContext(\"2d\");\n\t\tthis.cacheCanvas.width = width;\n\t\tthis.cacheCanvas.height = height;\n\t\tctx.setTransform(1, 0, 0, 1, -x, -y);\n\t\tctx.clearRect(0, 0, width+1, height+1); // because some browsers don't correctly clear if the width/height \n\t\t\t\t\t\t\t\t\t\t\t\t//remain the same.\n\t\tthis.draw(ctx, true);\n\t\tthis._cacheOffsetX = x;\n\t\tthis._cacheOffsetY = y;\n\t}\n\n\t/**\n\t* Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.\n\t* If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object\n\t* will be drawn over the existing cache using the specified compositeOperation.\n\t* @method updateCache\n\t* @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it. \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing\">\n\t* whatwg spec on compositing</a>.\n\t**/\n\tp.updateCache = function(compositeOperation) {\n\t\tif (this.cacheCanvas == null) { throw \"cache() must be called before updateCache()\"; }\n\t\tvar ctx = this.cacheCanvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, -this._cacheOffsetX, -this._cacheOffsetY);\n\t\tif (!compositeOperation) { ctx.clearRect(0, 0, this.cacheCanvas.width+1, this.cacheCanvas.height+1); }\n\t\telse { ctx.globalCompositeOperation = compositeOperation; }\n\t\tthis.draw(ctx, true);\n\t\tif (compositeOperation) { ctx.globalCompositeOperation = \"source-over\"; }\n\t}\n\t\n\t/**\n\t* Clears the current cache. See cache() for more information.\n\t* @method uncache\n\t**/\n\tp.uncache = function() {\n\t\tthis.cacheCanvas = null;\n\t\tthis.cacheOffsetX = this.cacheOffsetY = 0;\n\t}\n\t\n\t/**\n\t* Returns the stage that this display object will be rendered on, or null if it has not been added to one.\n\t* @method getStage\n\t* @return {Stage} The Stage instance that the display object is a descendent of. null if the DisplayObject has not \n\t* been added to a Stage.\n\t**/\n\tp.getStage = function() {\n\t\tvar o = this;\n\t\twhile (o.parent) {\n\t\t\to = o.parent;\n\t\t}\n\t\tif (o instanceof Stage) { return o; }\n\t\treturn null;\n\t}\n\n\t/**\n\t* Transforms the specified x and y position from the coordinate space of the display object\n\t* to the global (stage) coordinate space. For example, this could be used to position an HTML label\n\t* over a specific point on a nested display object. Returns a Point instance with x and y properties\n\t* correlating to the transformed coordinates on the stage.\n\t* @method localToGlobal\n\t* @param {Number} x The x position in the source display object to transform.\n\t* @param {Number} y The y position in the source display object to transform.\n\t* @return {Point} A Point instance with x and y properties correlating to the transformed coordinates \n\t* on the stage.\n\t**/\n\tp.localToGlobal = function(x, y) {\n\t\tvar mtx = this.getConcatenatedMatrix();\n\t\tif (mtx == null) { return null; }\n\t\tmtx.append(1, 0, 0, 1, x, y);\n\t\treturn new Point(mtx.tx, mtx.ty);\n\t}\n\n\t/**\n\t* Transforms the specified x and y position from the global (stage) coordinate space to the\n\t* coordinate space of the display object. For example, this could be used to determine\n\t* the current mouse position within the display object. Returns a Point instance with x and y properties\n\t* correlating to the transformed position in the display object's coordinate space.\n\t* @method globalToLocal\n\t* @param {Number} x The x position on the stage to transform.\n\t* @param {Number} y The y position on the stage to transform.\n\t* @return {Point} A Point instance with x and y properties correlating to the transformed position in the\n\t* display object's coordinate space.\n\t**/\n\tp.globalToLocal = function(x, y) {\n\t\tvar mtx = this.getConcatenatedMatrix();\n\t\tif (mtx == null) { return null; }\n\t\tmtx.invert();\n\t\tmtx.append(1, 0, 0, 1, x, y);\n\t\treturn new Point(mtx.tx, mtx.ty);\n\t}\n\n\t/**\n\t* Transforms the specified x and y position from the coordinate space of this display object to the\n\t* coordinate space of the target display object. Returns a Point instance with x and y properties\n\t* correlating to the transformed position in the target's coordinate space. Effectively the same as calling\n\t* var pt = this.localToGlobal(x, y); pt = target.globalToLocal(pt.x, pt.y);\n\t* @method localToLocal\n\t* @param {Number} x The x position in the source display object to transform.\n\t* @param {Number} y The y position on the stage to transform.\n\t* @param {DisplayObject} target The target display object to which the coordinates will be transformed.\n\t* @return {Point} Returns a Point instance with x and y properties correlating to the transformed position \n\t* in the target's coordinate space.\n\t**/\n\tp.localToLocal = function(x, y, target) {\n\t\tvar pt = this.localToGlobal(x, y);\n\t\treturn target.globalToLocal(pt.x, pt.y);\n\t}\n\n\t/**\n\t* Generates a concatenated Matrix2D object representing the combined transform of\n\t* the display object and all of its parent Containers up to the highest level ancestor\n\t* (usually the stage). This can be used to transform positions between coordinate spaces,\n\t* such as with localToGlobal and globalToLocal.\n\t* @method getConcatenatedMatrix\n\t* @param {Matrix2D} mtx Optional. A Matrix2D object to populate with the calculated values. If null, a new \n\t* Matrix object is returned.\n\t* @return {Matrix2D} a concatenated Matrix2D object representing the combined transform of\n\t* the display object and all of its parent Containers up to the highest level ancestor (usually the stage).\n\t**/\n\tp.getConcatenatedMatrix = function(mtx) {\n\t\tif (mtx) { mtx.identity(); }\n\t\telse { mtx = new Matrix2D(); }\n\t\tvar target = this;\n\t\twhile (target != null) {\n\t\t\tmtx.prependTransform(target.x, target.y, target.scaleX, target.scaleY, target.rotation, target.skewX, \n\t\t\t\t\t\t\t\t\ttarget.skewY, target.regX, target.regY);\n\t\t\tmtx.prependProperties(target.alpha, target.shadow, target.compositeOperation);\n\t\t\ttarget = target.parent;\n\t\t}\n\t\treturn mtx;\n\t}\n\n\t/**\n\t* Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at \n\t* the specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all \n\t* transform properties including regX/Y.\n\t* @method hitTest\n\t* @param {Number} x The x position to check in the display object's local coordinates.\n\t* @param {Number} y The y position to check in the display object's local coordinates.\n\t* @return {Boolean} A Boolean indicting whether a visible portion of the DisplayObject intersect the specified \n\t* local Point.\n\t*/\n\tp.hitTest = function(x, y) {\n\t\tvar ctx = DisplayObject._hitTestContext;\n\t\tvar canvas = DisplayObject._hitTestCanvas;\n\n\t\tctx.setTransform(1,  0, 0, 1, -x, -y);\n\t\tthis.draw(ctx);\n\t\t\n\t\tvar hit = this._testHit(ctx);\n\t\t\n\t\tcanvas.width = 0;\n\t\tcanvas.width = 1;\n\t\treturn hit;\n\t}\n\t\n\t/**\n\t* Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are \n\t* reverted to their defaults (for example .parent).\n\t* @method clone\n\t @return {DisplayObject} A clone of the current DisplayObject instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new DisplayObject();\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[DisplayObject (name=\"+  this.name +\")]\";\n\t}\n\t\n// private methods:\n\n\t// separated so it can be used more easily in subclasses:\n\t/**\n\t* @method cloneProps\n\t* @protected\n\t* @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject\n\t* instance copied into.\n\t**/\n\tp.cloneProps = function(o) {\n\t\to.alpha = this.alpha;\n\t\to.name = this.name;\n\t\to.regX = this.regX;\n\t\to.regY = this.regY;\n\t\to.rotation = this.rotation;\n\t\to.scaleX = this.scaleX;\n\t\to.scaleY = this.scaleY;\n\t\to.shadow = this.shadow;\n\t\to.skewX = this.skewX;\n\t\to.skewY = this.skewY;\n\t\to.visible = this.visible;\n\t\to.x  = this.x;\n\t\to.y = this.y;\n\t\to.mouseEnabled = this.mouseEnabled;\n\t\to.compositeOperation = this.compositeOperation;\n\t}\n\t\n\t/**\n\t* @method applyShadow\n\t* @protected\n\t* @param {CanvasRenderingContext2D} ctx\n\t* @param {Shadow} shadow\n\t**/\n\tp.applyShadow = function(ctx, shadow) {\n\t\tshadow = shadow || Shadow.identity;\n\t\tctx.shadowColor = shadow.color;\n\t\tctx.shadowOffsetX = shadow.offsetX;\n\t\tctx.shadowOffsetY = shadow.offsetY;\n\t\tctx.shadowBlur = shadow.blur;\n\t}\n\n\t/**\n\t* @method _testHit\n\t* @protected\n\t* @param {CanvasRenderingContext2D} ctx\n\t* @return {Boolean}\n\t**/\n\tp._testHit = function(ctx) {\n\t\ttry {\n\t\t\tvar hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n\t\t} catch (e) {\n\t\t\tif (!DisplayObject.suppressCrossDomainErrors) {\n\t\t\t\tthrow \"An error has occured. This is most likely due to security restrictions on reading canvas pixel \" +\n\t\t\t\t\"data with local or cross-domain images.\";\n\t\t\t}\n\t\t}\n\t\treturn hit;\n\t}\n\nwindow.DisplayObject = DisplayObject;\n}(window));"},{"id" : 45, "x" : 313, "y" : 627, "width" : 125, "height" : 37, "nodename" : "Graphics.js", "txt" : "/*\n* Graphics by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n// used to create the instruction lists used in Graphics:\n\n\n/**\n* Inner class used by the Graphics class. Used to create the instruction lists used in Graphics:\n* @class Command\n* @for Graphics\n* @constructor\n**/\nfunction Command(f, params) {\n\tthis.f = f;\n\tthis.params = params;\n}\n\n/**\n* @method exec\n* @param {Object} scope\n**/\nCommand.prototype.exec = function(scope) { this.f.apply(scope, this.params); }\n\n/**\n* The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a specified context.\n* Note that you can use Graphics without any dependency on the Easel framework by calling draw() directly,\n* or it can be used with the Shape object to draw vector graphics within the context of an Easel display list.<br/><br/>\n* Note that all drawing methods in Graphics return the Graphics instance, so they can be chained together. For example, the following \n* line of code would generate the instructions to draw a rectangle with a red stroke and blue fill, then render it to the specified \n* context2D:<br/>\n* myGraphics.beginStroke(\"#F00\").beginFill(\"#00F\").drawRect(20, 20, 100, 50).draw(myContext2D);\n* @class Graphics\n* @constructor\n* @param {String} instructions Optional. This is a string that will be eval'ed in the scope of this Graphics object. \n* This provides a mechanism for generating a vector shape from a serialized string. Ex. \n* \"beginFill('#F00');drawRect(0, 0, 10, 10);\"\n* @for Graphics\n**/\nGraphics = function(instructions) {\n\tthis.initialize(instructions);\n}\nvar p = Graphics.prototype;\n\n// static public methods:\n\t\n\t/**\n\t* Returns a CSS compatible color string based on the specified RGB numeric color values in the format \n\t* \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\". For example,\n\t* Graphics.getRGB(50, 100, 150, 0.5) will return \"rgba(50,100,150,0.5)\". It also supports passing a single hex color \n\t* value as the first param, and an optional alpha value as the second param. For example, Graphics.getRGB(0xFF00FF, 0.2)\n\t* will return \"rgba(255,0,255,0.2)\".\n\t* @method getRGB\n\t* @static\n\t* @param {Number} r The red component for the color, between 0 and 0xFF (255).\n\t* @param {Number} g The green component for the color, between 0 and 0xFF (255).\n\t* @param {Number} b The blue component for the color, between 0 and 0xFF (255).\n\t* @param {Number} alpha Optional. The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t* @return A CSS compatible color string based on the specified RGB numeric color values in the format \n\t* \"rgba(255,255,255,1.0)\", or if alpha is null then in the format \"rgb(255,255,255)\".\n\t**/\n\tGraphics.getRGB = function(r, g, b, alpha) {\n\t\tif (r != null && b == null) {\n\t\t\talpha = g;\n\t\t\tb = r&0xFF;\n\t\t\tg = r>>8&0xFF;\n\t\t\tr = r>>16&0xFF;\n\t\t}\n\t\tif (alpha == null) {\n\t\t\treturn \"rgb(\"+r+\",\"+g+\",\"+b+\")\";\n\t\t} else {\n\t\t\treturn \"rgba(\"+r+\",\"+g+\",\"+b+\",\"+alpha+\")\";\n\t\t}\n\t}\n\t\n\t/**\n\t* Returns a CSS compatible color string based on the specified HSL numeric color values in the format \"hsla(360,100,100,1.0)\", \n\t* or if alpha is null then in the format \"hsl(360,100,100)\". For example, Graphics.getHSL(150, 100, 70) will return \n\t* \"hsl(150,100,70)\".\n\t* @method getHSL\n\t* @static\n\t* @param {Number} hue The hue component for the color, between 0 and 360.\n\t* @param {Number} saturation The saturation component for the color, between 0 and 100.\n\t* @param {Number} lightness The lightness component for the color, between 0 and 100.\n\t* @param {Number} alpha Optional. The alpha component for the color where 0 is fully transparent and 1 is fully opaque.\n\t* @return a CSS compatible color string based on the specified HSL numeric color values in the format \n\t* \"hsla(360,100,100,1.0)\", or if alpha is null then in the format \"hsl(360,100,100)\". For example, \n\t* Graphics.getHSL(150, 100, 70) will return \"hsl(150,100,70)\".\n\t**/\n\tGraphics.getHSL = function(hue, saturation, lightness, alpha) {\n\t\tif (alpha == null) {\n\t\t\treturn \"hsl(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%)\";\n\t\t} else {\n\t\t\treturn \"hsla(\"+(hue%360)+\",\"+saturation+\"%,\"+lightness+\"%,\"+alpha+\")\";\n\t\t}\n\t}\n\t\n\t/**\n\t* Maps numeric values for the caps parameter of setStrokeStyle to corresponding string values.\n\t* This is primarily for use with the tiny API. The mappings are as follows: 0 to \"butt\",\n\t* 1 to \"round\", and 2 to \"square\".\n\t* For example, myGraphics.ss(16, 2) would set the line caps to \"square\".\n\t* @property STROKE_CAPS_MAP\n\t* @static\n\t* @final\n\t* @type Array[String]\n\t**/\n\tGraphics.STROKE_CAPS_MAP = [\"butt\", \"round\", \"square\"];\n\t\n\t/**\n\t* Maps numeric values for the joints parameter of setStrokeStyle to corresponding string values.\n\t* This is primarily for use with the tiny API. The mappings are as follows: 0 to \"miter\",\n\t* 1 to \"round\", and 2 to \"bevel\".\n\t* For example, myGraphics.ss(16, 0, 2) would set the line joints to \"bevel\".\n\t* @property STROKE_JOINTS_MAP\n\t* @static\n\t* @final\n\t* @type Array[String]\n\t**/\n\tGraphics.STROKE_JOINTS_MAP = [\"miter\", \"round\", \"bevel\"];\n\t\n\t/**\n\t* @property _ctx\n\t* @static\n\t* @protected\n\t* @type CanvasRenderingContext2D\n\t**/\n\tGraphics._ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\t\n\t/**\n\t* @property beginCmd\n\t* @static\n\t* @protected\n\t* @type Command\n\t**/\n\tGraphics.beginCmd = new Command(Graphics._ctx.beginPath, []);\n\t\n\t/**\n\t* @property fillCmd\n\t* @static\n\t* @protected\n\t* @type Command\n\t**/\n\tGraphics.fillCmd = new Command(Graphics._ctx.fill, []);\n\t\n\t/**\n\t* @property strokeCmd\n\t* @static\n\t* @protected\n\t* @type Command\n\t**/\n\tGraphics.strokeCmd = new Command(Graphics._ctx.stroke, []);\n\n\t/**\n\t* @property _strokeInstructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._strokeInstructions = null;\n\n\t/**\n\t* @property _strokeStyleInstructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._strokeStyleInstructions = null;\n\t\n\t/**\n\t* @property _fillInstructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._fillInstructions = null;\n\t\n\t/**\n\t* @property _instructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._instructions = null;\n\t\n\t/**\n\t* @property _oldInstructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._oldInstructions = null;\n\t\n\t/**\n\t* @property _activeInstructions\n\t* @protected\n\t* @type Array[Command]\n\t**/\n\tp._activeInstructions = null;\n\t\n\t/**\n\t* @property _active\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp._active = false;\n\t\n\t/**\n\t* @property _dirty\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp._dirty = false;\n\t\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t* @param {String} instructions\n\t**/\n\tp.initialize = function(instructions) {\n\t\tthis.clear();\n\t\tthis._ctx = Graphics._ctx;\n\t\twith (this) { eval(instructions); }\n\t}\n\t\n\t/**\n\t* Draws the display object into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t**/\n\tp.draw = function(ctx) {\n\t\tif (this._dirty) {\n\t\t\tthis._updateInstructions();\n\t\t}\n\t\tvar instr = this._instructions;\n\t\tfor (var i=0, l=instr.length; i<l; i++) {\n\t\t\tinstr[i].exec(ctx);\n\t\t}\n\t}\n\t\n// public methods that map directly to context 2D calls:\n\t/**\n\t* Moves the drawing point to the specified position.\n\t* @method moveTo\n\t* @param {Number} x The x coordinate the drawing point should move to.\n\t* @param {Number} y The y coordinate the drawing point should move to.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.moveTo = function(x, y) {\n\t\tthis._activeInstructions.push(new Command(this._ctx.moveTo, [x, y]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a line from the current drawing point to the specified position, which become the new current drawing point. \n\t* For detailed information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)\">\n\t* whatwg spec</a>.\n\t* @method lineTo\n\t* @param {Number} x The x coordinate the drawing point should draw to.\n\t* @param {Number} y The y coordinate the drawing point should draw to.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.lineTo = function(x, y) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(new Command(this._ctx.lineTo, [x, y]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws an arc with the specified control points and radius.  For detailed information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto\">\n\t* whatwg spec</a>.\n\t* @method arcTo\n\t* @param {Number} x1\n\t* @param {Number} y1\n\t* @param {Number} x2\n\t* @param {Number} y2\n\t* @param {Number} radius\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.arcTo = function(x1, y1, x2, y2, radius) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(new Command(this._ctx.arcTo, [x1, y1, x2, y2, radius]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For example \n\t* arc(100, 100, 20, 0, Math.PI*2) would draw a full circle with a radius of 20 centered at (100, 100). For detailed \n\t* information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\">whatwg spec</a>.\n\t* @method arc\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Number} radius\n\t* @param {Number} startAngle Measured in radians.\n\t* @param {Number} endAngle Measured in radians.\n\t* @param {Boolean} anticlockwise\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {\n\t\tthis._dirty = this._active = true;\n\t\tif (anticlockwise == null) { anticlockwise = false; }\n\t\tthis._activeInstructions.push(new Command(this._ctx.arc, [x, y, radius, startAngle, endAngle, anticlockwise]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy).  For detailed information, \n\t* read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n\t* whatwg spec</a>.\n\t* @method quadraticCurveTo\n\t* @param {Number} cpx\n\t* @param {Number} cpy\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.quadraticCurveTo = function(cpx, cpy, x, y) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(new Command(this._ctx.quadraticCurveTo, [cpx, cpy, x, y]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x, cp2y).  \n\t* For detailed information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto\">\n\t* whatwg spec</a>.\n\t* method @bezierCurveTo\n\t* @param {Number} cp1x\n\t* @param {Number} cp1y\n\t* @param {Number} cp2x\n\t* @param {Number} cp2y\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(new Command(this._ctx.bezierCurveTo, [cp1x, cp1y, cp2x, cp2y, x, y]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.\n\t*  For detailed information, read the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect\">\n\t* whatwg spec</a>.\n\t* @method rect\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Number} w Width of the rectangle\n\t* @param {Number} h Height of the rectangle\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.rect = function(x, y, w, h) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(new Command(this._ctx.rect, [x, y, w-1, h]));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n\t* since the fill or stroke was last set.\n\t* @method closePath\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.closePath = function() {\n\t\tif (this._active) {\n\t\t\tthis._dirty = true;\n\t\t\tthis._activeInstructions.push(new Command(this._ctx.closePath, []));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t\n// public methods that roughly map to Flash graphics APIs:\n\t/**\n\t* Clears all drawing instructions, effectively reseting this Graphics instance.\n\t* @method clear\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.clear = function() {\n\t\tthis._instructions = [];\n\t\tthis._oldInstructions = [];\n\t\tthis._activeInstructions = [];\n\t\tthis._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;\n\t\tthis._active = this._dirty = false;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a fill with the specified color. This ends the current subpath.\n\t* @method beginFill\n\t* @param {String} color A CSS compatible color value (ex. \"#FF0000\" or \"rgba(255,0,0,0.5)\"). Setting to null will \n\t* result in no fill.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginFill = function(color) {\n\t\tif (this._active) { this._newPath(); }\n\t\tthis._fillInstructions = color ? [new Command(this._setProp, [\"fillStyle\", color])] : null;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current subpath. For example, the\n\t* following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a square to display it:<br/>\n\t* myGraphics.beginLinearGradientFill([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t* @method beginLinearGradientFill\n\t* @param {Array[String]} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient \n\t* drawing from red to blue.\n\t* @param {Array[Number]} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw \n\t* the first color to 10% then interpolating to the second color at 90%.\n\t* @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.\n\t* @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.\n\t* @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.\n\t* @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {\n\t\tif (this._active) { this._newPath(); }\n\t\tvar o = this._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) {\n\t\t\to.addColorStop(ratios[i], colors[i]);\n\t\t}\n\t\tthis._fillInstructions = [new Command(this._setProp, [\"fillStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a radial gradient fill. This ends the current subpath. For example, the following code defines a red to blue radial \n\t* gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:<br/>\n\t* myGraphics.beginRadialGradientFill([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);\n\t* @method beginRadialGradientFill\n\t* @param {Array[String]} colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient \n\t* drawing from red to blue.\n\t* @param {Array[Number]} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would \n\t* draw the first color to 10% then interpolating to the second color at 90%.\n\t* @param {Number} x0 Center position of the inner circle that defines the gradient.\n\t* @param {Number} y0 Center position of the inner circle that defines the gradient.\n\t* @param {Number} r0 Radius of the inner circle that defines the gradient.\n\t* @param {Number} x1 Center position of the outer circle that defines the gradient.\n\t* @param {Number} y1 Center position of the outer circle that defines the gradient.\n\t* @param {Number} r1 Radius of the outer circle that defines the gradient.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tif (this._active) { this._newPath(); }\n\t\tvar o = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) {\n\t\t\to.addColorStop(ratios[i], colors[i]);\n\t\t}\n\t\tthis._fillInstructions = [new Command(this._setProp, [\"fillStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a pattern fill using the specified image. This ends the current subpath.\n\t* @method beginBitmapFill\n\t* @param image The Image, Canvas, or Video object to use as the pattern.\n\t* @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\", \"repeat-x\",\n\t* \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginBitmapFill = function(image, repetition) {\n\t\tif (this._active) { this._newPath(); }\n\t\trepetition = repetition || \"\";\n\t\tvar o = this._ctx.createPattern(image, repetition);\n\t\tthis._fillInstructions = [new Command(this._setProp, [\"fillStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Ends the current subpath, and begins a new one with no fill. Functionally identical to beginFill(null).\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.endFill = function() {\n\t\tthis.beginFill(null);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Sets the stroke style for the current subpath. Like all drawing methods, this can be chained, so you can define the stroke style and color in a single line of code like so:\n\t* myGraphics.setStrokeStyle(8,\"round\").beginStroke(\"#F00\");\n\t* @param thickness The width of the stroke.\n\t* @param caps Optional. Indicates the type of caps to use at the end of lines. One of butt, round, or square. Defaults to \"butt\". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with the tiny API.\n\t* @param joints Optional. Specifies the type of joints that should be used where two lines meet. One of bevel, round, or miter. Defaults to \"miter\". Also accepts the values 0 (miter), 1 (round), and 2 (bevel) for use with the tiny API.\n\t* @param miter Optional. If joints is set to \"miter\", then you can specify a miter limit ratio which controls at what point a mitered joint will be clipped.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.setStrokeStyle = function(thickness, caps, joints, miterLimit) {\n\t\tif (this._active) { this._newPath(); }\n\t\tthis._strokeStyleInstructions = [\n\t\t\tnew Command(this._setProp, [\"lineWidth\", (thickness == null ? \"1\" : thickness)]),\n\t\t\tnew Command(this._setProp, [\"lineCap\", (caps == null ? \"butt\" : (isNaN(caps) ? caps : Graphics.STROKE_CAPS_MAP[caps]))]),\n\t\t\tnew Command(this._setProp, [\"lineJoin\", (joints == null ? \"miter\" : (isNaN(joints) ? joints : Graphics.STROKE_JOINTS_MAP[joints]))]),\n\t\t\tnew Command(this._setProp, [\"miterLimit\", (miterLimit == null ? \"10\" : miterLimit)])\n\t\t\t];\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a stroke with the specified color. This ends the current subpath.\n\t* @param color A CSS compatible color value (ex. \"#FF0000\" or \"rgba(255,0,0,0.5)\"). Setting to null will result in no stroke.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginStroke = function(color) {\n\t\tif (this._active) { this._newPath(); }\n\t\tthis._strokeInstructions = color ? [new Command(this._setProp, [\"strokeStyle\", color])] : null;\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current subpath. For example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a square to display it:<br/>\n\t* myGraphics.setStrokeStyle(10).beginLinearGradientStroke([\"#000\",\"#FFF\"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);\n\t* @param colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient drawing from red to blue.\n\t* @param ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw the first color to 10% then interpolating to the second color at 90%.\n\t* @param x0 The position of the first point defining the line that defines the gradient direction and size.\n\t* @param y0 The position of the first point defining the line that defines the gradient direction and size.\n\t* @param x1 The position of the second point defining the line that defines the gradient direction and size.\n\t* @param y1 The position of the second point defining the line that defines the gradient direction and size.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {\n\t\tif (this._active) { this._newPath(); }\n\t\tvar o = this._ctx.createLinearGradient(x0, y0, x1, y1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) {\n\t\t\to.addColorStop(ratios[i], colors[i]);\n\t\t}\n\t\tthis._strokeInstructions = [new Command(this._setProp, [\"strokeStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t* Begins a radial gradient stroke. This ends the current subpath. For example, the following code defines a red to blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:<br/>\n\t* myGraphics.setStrokeStyle(10).beginRadialGradientStroke([\"#F00\",\"#00F\"], [0, 1], 100, 100, 0, 100, 100, 50).drawRect(50, 90, 150, 110);\n\t* @param colors An array of CSS compatible color values. For example, [\"#F00\",\"#00F\"] would define a gradient drawing from red to blue.\n\t* @param ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color to 100%.\n\t* @param x0 Center position of the inner circle that defines the gradient.\n\t* @param y0 Center position of the inner circle that defines the gradient.\n\t* @param r0 Radius of the inner circle that defines the gradient.\n\t* @param x1 Center position of the outer circle that defines the gradient.\n\t* @param y1 Center position of the outer circle that defines the gradient.\n\t* @param r1 Radius of the outer circle that defines the gradient.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\t\n\t**/\n\tp.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {\n\t\tif (this._active) { this._newPath(); }\n\t\tvar o = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\t\tfor (var i=0, l=colors.length; i<l; i++) {\n\t\t\to.addColorStop(ratios[i], colors[i]);\n\t\t}\n\t\tthis._strokeInstructions = [new Command(this._setProp, [\"strokeStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Begins a pattern fill using the specified image. This ends the current subpath.\n\t* @param {Image | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use as the pattern.\n\t* @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of \"repeat\", \"repeat-x\",\n\t* \"repeat-y\", or \"no-repeat\". Defaults to \"repeat\".\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\t\n\t**/\n\tp.beginBitmapStroke = function(image, repetition) {\n\t\tif (this._active) { this._newPath(); }\n\t\trepetition = repetition || \"\";\n\t\tvar o = this._ctx.createPattern(image, repetition);\n\t\tthis._strokeInstructions = [new Command(this._setProp, [\"strokeStyle\", o])];\n\t\treturn this;\n\t}\n\t\n\t\n\t/**\n\t* Ends the current subpath, and begins a new one with no stroke. Functionally identical to beginStroke(null).\n\t* @method endStroke\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.endStroke = function() {\n\t\tthis.beginStroke(null);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Maps the familiar ActionScript curveTo() method to the functionally similar quatraticCurveTo() method.\n\t* @property curveTo\n\t* @type Function\n\t**/\n\tp.curveTo = p.quadraticCurveTo;\n\t\n\t/**\n\t* Maps the familiar ActionScript drawRect() method to the functionally similar rect() method.\n\t* @property drawRect\n\t* @type Function\n\t**/\n\tp.drawRect = p.rect;\n\t\n\t/**\n\t* Draws a rounded rectangle with all corners with the specified radius.\n\t* @method drawRoundRect\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Number} w\n\t* @param {Number} h\n\t* @param {Number} radius Corner radius.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.drawRoundRect = function(x, y, w, h, radius) {\n\t\tthis.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a rounded rectangle with different corner radiuses.\n\t* @method drawRoundRectComplex\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Number} w\n\t* @param {Number} h\n\t* @param {Number} radiusTL Top left corner radius.\n\t* @param {Number} radiusTR Top right corner radius.\n\t* @param {Number} radiusBR Bottom right corner radius.\n\t* @param {Number} radiusBL Bottom left corner radius.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {\n\t\tthis._dirty = this._active = true;\n\t\tthis._activeInstructions.push(\n\t\t\tnew Command(this._ctx.moveTo, [x+radiusTL, y]),\n\t\t\tnew Command(this._ctx.lineTo, [x+w-radiusTR, y]),\n\t\t\tnew Command(this._ctx.arc, [x+w-radiusTR, y+radiusTR, radiusTR, (-Math.PI/2), 0, false]),\n\t\t\tnew Command(this._ctx.lineTo, [x+w, y+h-radiusBR]),\n\t\t\tnew Command(this._ctx.arc, [x+w-radiusBR, y+h-radiusBR, radiusBR, 0, Math.PI/2, false]),\n\t\t\tnew Command(this._ctx.lineTo, [x+radiusBL, y+h]),\n\t\t\tnew Command(this._ctx.arc, [x+radiusBL, y+h-radiusBL, radiusBL, Math.PI/2, Math.PI, false]),\n\t\t\tnew Command(this._ctx.lineTo, [x, y+radiusTL]),\n\t\t\tnew Command(this._ctx.arc, [x+radiusTL, y+radiusTL, radiusTL, Math.PI, Math.PI*3/2, false])\n\t\t);\n\t\treturn this;\n\t} \n\t\n\t/**\n\t* Draws a circle with the specified radius at (x, y).\n\t* @method drawCircle\n\t* @param {Number} x x coordinate center point of circle.\n\t* @param {Number} y y coordinate center point of circle.\n\t* @param {Number} radius Radius of circle.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.drawCircle = function(x, y, radius) {\n\t\tthis.arc(x, y, radius, 0, Math.PI*2);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws an ellipse (oval).\n\t* @method drawEllipse\n\t* @param {Number} x\n\t* @param {Number} y\n\t* @param {Number} w\n\t* @param {Number} h\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.drawEllipse = function(x, y, w, h) {\n\t\tthis._dirty = this._active = true;\n\t\tvar k = 0.5522848;\n\t\tvar ox = (w / 2) * k;\n\t\tvar oy = (h / 2) * k;\n\t\tvar xe = x + w;\n\t\tvar ye = y + h;\n\t\tvar xm = x + w / 2;\n\t\tvar ym = y + h / 2;\n\t\t\t\n\t\tthis._activeInstructions.push(\n\t\t\tnew Command(this._ctx.moveTo, [x, ym]),\n\t\t\tnew Command(this._ctx.bezierCurveTo, [x, ym-oy, xm-ox, y, xm, y]),\n\t\t\tnew Command(this._ctx.bezierCurveTo, [xm+ox, y, xe, ym-oy, xe, ym]),\n\t\t\tnew Command(this._ctx.bezierCurveTo, [xe, ym+oy, xm+ox, ye, xm, ye]),\n\t\t\tnew Command(this._ctx.bezierCurveTo, [xm-ox, ye, x, ym+oy, x, ym])\n\t\t);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Draws a star if pointSize is greater than 0 or a regular polygon if pointSize is 0 with the specified number of points.\n\t* For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a radius of 50:\n\t* myGraphics.beginFill(\"#FF0\").drawPolyStar(100, 100, 50, 5, 0.6, -90); // -90 makes the first point vertical\n\t* @method drawPolyStar\n\t* @param {Number} x Position of the center of the shape.\n\t* @param {Number} y Position of the center of the shape.\n\t* @param {Number} radius The outer radius of the shape.\n\t* @param {Number} sides The number of points on the star or sides on the polygon.\n\t* @param {Number} pointSize The depth or \"pointy-ness\" of the star points. A pointSize of 0 will draw a regular polygon (no points), \n\t* a pointSize of 1 will draw nothing because the points are infinitely pointy.\n\t* @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point directly to the \n\t* right of the center.\n\t* @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n\t**/\n\tp.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {\n\t\tthis._dirty = this._active = true;\n\t\tif (pointSize == null) { pointSize = 0; }\n\t\tpointSize = 1-pointSize;\n\t\tif (angle == null) { angle = 0; }\n\t\telse { angle /= 180/Math.PI; }\n\t\tvar a = Math.PI/sides;\n\t\t\n\t\tthis._activeInstructions.push(new Command(this._ctx.moveTo, [x+Math.cos(angle)*radius, y+Math.sin(angle)*radius]));\n\t\tfor (var i=0; i<sides; i++) {\n\t\t\tangle += a;\n\t\t\tif (pointSize != 1) {\n\t\t\t\tthis._activeInstructions.push(new Command(this._ctx.lineTo, [x+Math.cos(angle)*radius*pointSize, y+Math.sin(angle)*radius*pointSize]));\n\t\t\t}\n\t\t\tangle += a;\n\t\t\tthis._activeInstructions.push(new Command(this._ctx.lineTo, [x+Math.cos(angle)*radius, y+Math.sin(angle)*radius]));\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t* Returns a clone of this Graphics instance.\n\t* @method clone\n\t @return {Graphics} A clone of the current Graphics instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new Graphics();\n\t\to._instructions = this._instructions.slice();\n\t\to._activeInstructions = this._activeInstructions.slice();\n\t\to._oldInstructions = this._oldInstructions.slice();\n\t\tif (this._fillInstructions) { o._fillInstructions = this._fillInstructions.slice(); }\n\t\tif (this._strokeInstructions) { o._strokeInstructions = this._strokeInstructions.slice(); }\n\t\tif (this._strokeStyleInstructions) { o._strokeStyleInstructions = this._strokeStyleInstructions.slice(); }\n\t\to._active = this._active;\n\t\to._dirty = this._dirty;\n\t\treturn o;\n\t}\n\t\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Graphics]\";\n\t}\n\t\n\t\n// tiny API:\n\t/** Shortcut to moveTo.\n\t* @property mt\n\t* @protected\n\t* type Function\n\t**/\n\tp.mt = p.moveTo;\n\t\n\t/** Shortcut to lineTo.\n\t* @property lt\n\t* @protected\n\t* type Function\n\t**/\n\tp.lt = p.lineTo;\n\t\n\t/** Shortcut to arcTo.\n\t* @property at\n\t* @protected\n\t* type Function\n\t**/\n\tp.at = p.arcTo;\n\t\n\t/** Shortcut to bezierCurveTo.\n\t* @property bt\n\t* @protected\n\t* type Function\n\t**/\n\tp.bt = p.bezierCurveTo;\n\t\n\t/** Shortcut to quadraticCurveTo / curveTo.\n\t* @property qt\n\t* @protected\n\t* type Function\n\t**/\n\tp.qt = p.quadraticCurveTo;\n\t\n\t/** Shortcut to arc.\n\t* @property a\n\t* @protected\n\t* type Function\n\t**/\n\tp.a = p.arc;\n\t\n\t/** Shortcut to rect.\n\t* @property r\n\t* @protected\n\t* type Function\n\t**/\n\tp.r = p.rect;\n\t\n\t/** Shortcut to closePath.\n\t* @property cp\n\t* @protected\n\t* type Function\n\t**/\n\tp.cp = p.closePath;\n\t\n\t/** Shortcut to clear.\n\t* @property c\n\t* @protected\n\t* type Function\n\t**/\n\tp.c = p.clear;\n\t\n\t/** Shortcut to beginFill.\n\t* @property f\n\t* @protected\n\t* type Function\n\t**/\n\tp.f = p.beginFill;\n\t\n\t/** Shortcut to beginLinearGradientFill.\n\t* @property lf\n\t* @protected\n\t* type Function\n\t**/\n\tp.lf = p.beginLinearGradientFill;\n\t\n\t/** Shortcut to beginRadialGradientFill.\n\t* @property rf\n\t* @protected\n\t* type Function\n\t**/\n\tp.rf = p.beginRadialGradientFill;\n\t\n\t/** Shortcut to beginBitmapFill.\n\t* @property bf\n\t* @protected\n\t* type Function\n\t**/\n\tp.bf = p.beginBitmapFill;\n\t\n\t/** Shortcut to endFill.\n\t* @property ef\n\t* @protected\n\t* type Function\n\t**/\n\tp.ef = p.endFill;\n\t\n\t/** Shortcut to setStrokeStyle.\n\t* @property ss\n\t* @protected\n\t* type Function\n\t**/\n\tp.ss = p.setStrokeStyle;\n\t\n\t/** Shortcut to beginStroke.\n\t* @property s\n\t* @protected\n\t* type Function\n\t**/\n\tp.s = p.beginStroke;\n\t\n\t/** Shortcut to beginLinearGradientStroke.\n\t* @property ls\n\t* @protected\n\t* type Function\n\t**/\n\tp.ls = p.beginLinearGradientStroke;\n\t\n\t/** Shortcut to beginRadialGradientStroke.\n\t* @property rs\n\t* @protected\n\t* type Function\n\t**/\n\tp.rs = p.beginRadialGradientStroke;\n\t\n\t/** Shortcut to beginBitmapStroke.\n\t* @property bs\n\t* @protected\n\t* type Function\n\t**/\n\tp.bs = p.beginBitmapStroke;\n\t\n\t/** Shortcut to endStroke.\n\t* @property es\n\t* @protected\n\t* type Function\n\t**/\n\tp.es = p.endStroke;\n\t\n\t/** Shortcut to drawRect.\n\t* @property dr\n\t* @protected\n\t* type Function\n\t**/\n\tp.dr = p.drawRect;\n\t\n\t/** Shortcut to drawRoundRect.\n\t* @property rr\n\t* @protected\n\t* type Function\n\t**/\n\tp.rr = p.drawRoundRect;\n\t\n\t/** Shortcut to drawRoundRectComplex.\n\t* @property rc\n\t* @protected\n\t* type Function\n\t**/\n\tp.rc = p.drawRoundRectComplex;\n\t\n\t/** Shortcut to drawCircle.\n\t* @property dc\n\t* @protected\n\t* type Function\n\t**/\n\tp.dc = p.drawCircle;\n\t\n\t/** Shortcut to drawEllipse.\n\t* @property de\n\t* @protected\n\t* type Function\n\t**/\n\tp.de = p.drawEllipse;\n\t\n\t/** Shortcut to drawPolyStar.\n\t* @property dp\n\t* @protected\n\t* type Function\n\t**/\n\tp.dp = p.drawPolyStar;\n\t\n\t\n// private methods:\n\t/**\n\t* @method _updateInstructions\n\t* @protected\n\t**/\n\tp._updateInstructions = function() {\n\t\tthis._instructions = this._oldInstructions.slice()\n\t\tthis._instructions.push(Graphics.beginCmd);\n\t\t \n\t\tif (this._fillInstructions) { this._instructions.push.apply(this._instructions, this._fillInstructions); }\n\t\tif (this._strokeInstructions) {\n\t\t\tthis._instructions.push.apply(this._instructions, this._strokeInstructions);\n\t\t\tif (this._strokeStyleInstructions) {\n\t\t\t\tthis._instructions.push.apply(this._instructions, this._strokeStyleInstructions);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis._instructions.push.apply(this._instructions, this._activeInstructions);\n\t\t\n\t\tif (this._fillInstructions) { this._instructions.push(Graphics.fillCmd); }\n\t\tif (this._strokeInstructions) { this._instructions.push(Graphics.strokeCmd); }\n\t}\n\t\n\t/**\n\t* @method _newPath\n\t* @protected\n\t**/\n\tp._newPath = function() {\n\t\tif (this._dirty) { this._updateInstructions(); }\n\t\tthis._oldInstructions = this._instructions;\n\t\tthis._activeInstructions = [];\n\t\tthis._active = this._dirty = false;\n\t}\n\t\n\t// used to create Commands that set properties:\n\t/**\n\t* used to create Commands that set properties\n\t* @method _setProp\n\t* @param {String} name\n\t* @param {String} value\n\t* @protected\n\t**/\n\tp._setProp = function(name, value) {\n\t\tthis[name] = value;\n\t}\n\nwindow.Graphics = Graphics;\n}(window));"},{"id" : 46, "x" : 312, "y" : 674.5, "width" : 125, "height" : 38, "nodename" : "Shadow.js", "txt" : "/*\n* Shadow by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* Encapsulates the properties required to define a shadow to apply to a DisplayObject via it's .shadow property.\n* @class Shadow\n* @constructor\n* @param {String} color The color of the shadow.\n* @param {Number} offsetX The x offset of the shadow.\n* @param {Number} offsetY The y offset of the shadow.\n* @param {Number} blur The size of the blurring effect.\n**/\nShadow = function(color, offsetX, offsetY, blur) {\n  this.initialize(color, offsetX, offsetY, blur);\n}\nvar p = Shadow.prototype;\n\t\n// static public properties:\n\t/**\n\t* An identity shadow object (all properties are set to 0). Read-only.\n\t* @property identity\n\t* @type Shadow\n\t* @static\n\t* @final\n\t**/\n\tShadow.identity = null; // set at bottom of class definition.\n\t\n// public properties:\n\t/** The color of the shadow.\n\t* property color\n\t* @type String\n\t* @default null\n\t*/\n\tp.color = null;\n\t\n\t/** The x offset of the shadow.\n\t* property offsetX\n\t* @type Number\n\t* @default 0\n\t*/\n\tp.offsetX = 0;\n\t\n\t/** The y offset of the shadow.\n\t* property offsetY\n\t* @type Number\n\t* @default 0\n\t*/\n\tp.offsetY = 0;\n\t\n\t/** The blur of the shadow.\n\t* property blur\n\t* @type Number\n\t* @default 0\n\t*/\n\tp.blur = 0;\n\t\n// constructor:\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t* @param {Array[Command]} instructions\n\t**/\n\tp.initialize = function(color, offsetX, offsetY, blur) {\n\t\tthis.color = color;\n\t\tthis.offsetX = offsetX;\n\t\tthis.offsetY = offsetY;\n\t\tthis.blur = blur;\n\t}\n\t\n// public methods:\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Shadow]\";\n\t}\n\t\n\t\n\t/**\n\t* Returns a clone of this Shadow instance.\n\t* @method clone\n\t @return {Shadow} A clone of the current Shadow instance.\n\t**/\n\tp.clone = function() {\n\t\treturn new Shadow(this.color, this.offsetX, this.offsetY, this.blur);\n\t}\n\t\n\t// this has to be populated after the class is defined:\n\tShadow.identity = new Shadow(null, 0, 0, 0);\n\t\nwindow.Shadow = Shadow;\n}(window));"},{"id" : 47, "x" : 312, "y" : 722, "width" : 130, "height" : 41, "nodename" : "Shape.js", "txt" : "/*\n* Shape by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* A Shape allows you to display vector art in the display list. It composites a Graphics instance which exposes all of the vector\n* drawing methods. The Graphics instance can be shared between multiple Shape instances to display the same vector graphics with different\n* positions or transforms. If the vector art will not change between draws, you may want to use the cache() method to reduce the rendering cost.\n* @class Shape\n* @extends DisplayObject\n* @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.\n**/\nShape = function(graphics) {\n  this.initialize(graphics);\n}\nvar p = Shape.prototype = new DisplayObject();\n\n// public properties:\n\t/**\n\t* The graphics instance to display.\n\t* @property graphics\n\t* @type Graphics\n\t**/\n\tp.graphics = null;\n\t\n// constructor:\n\t/**\n\t* @property DisplayObject_initialize\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_initialize = p.initialize;\n\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* param {Graphics} graphics\n\t* @protected\n\t**/\n\tp.initialize = function(graphics) {\n\t\tthis.DisplayObject_initialize();\n\t\tthis.graphics = graphics ? graphics : new Graphics();\n\t}\n\n\t/**\n\t* Returns true or false indicating whether the Shape would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\treturn this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && this.graphics;\n\t}\n\n\t/**\n\t* @property DisplayObject_draw\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_draw = p.draw;\n\t\n\t/**\n\t* Draws the Shape into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\tthis.graphics.draw(ctx);\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to \n\t* their defaults (for example .parent).\n\t* @method clone\n\t* @param {Boolean} recursive If true, this Shape's Graphics instance will also be cloned. If false, the Graphics instance \n\t* will be shared with the new Shape.\n\t**/\n\tp.clone = function(recursive) {\n\t\tvar o = new Shape((recursive && this.graphics) ? this.graphics.clone() : this.graphics);\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Shape (name=\"+  this.name +\")]\";\n\t}\n\nwindow.Shape = Shape;\n}(window));"},{"id" : 48, "x" : 310, "y" : 773, "width" : 129, "height" : 38, "nodename" : "SpriteSheet.js", "txt" : "/*\n* SpriteSheet by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* Encapsulates the properties associated with a sprite sheet. A sprite sheet is a series of images (usually animation frames) combined\n* into a single image on a regular grid. For example, an animation consisting of 8 100x100 images could be combined into a 400x200 \n* sprite sheet (4 frames across by 2 high).\n* The simplest form of sprite sheet has values for the image, frameWidth, and frameHeight properties, but does not include frameData. \n* It will then play all of the frames in the animation and loop if the loop property is true. In this simple mode, you can also set \n* the totalFrames property if you have extraneous frames in your sprite sheet (for example, a 2x4 frame sprite sheet, with only 7 \n* frames used).<br/><br/>\n* More complex sprite sheets include a frameData property, which provides named frames and animations which can be played and sequenced \n* together. See frameData for more information.\n* @class SpriteSheet\n* @constructor\n* @param {Image | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video instance to use as a sprite sheet.\n* @param {Number} frameWidth The width in pixels of each frame on the sprite sheet.\n* @param {Number} frameHeight The height in pixels of each frame on the sprite sheet.\n* @param {Object} frameData Defines named frames and frame sequences. See the frameData property for more information.\n**/\nSpriteSheet = function(image, frameWidth, frameHeight, frameData) {\n  this.initialize(image, frameWidth, frameHeight, frameData);\n}\nvar p = SpriteSheet.prototype;\n\t\n// public properties:\n\t/**\n\t* The Image, Canvas, or Video instance to use as a sprite sheet.\n\t* @property image\n\t* @type Image | HTMLCanvasElement | HTMLVideoElement\n\t**/\n\tp.image = null;\n\t\n\t/** The width in pixels of each frame on the sprite sheet image.\n\t* @property frameWidth\n\t* @type Number\n\t**/\n\tp.frameWidth = 0;\n\t\n\t/** The height in pixels of each frame on the sprite sheet image.\n\t* @property frameHeight\n\t* @type Number\n\t**/\n\tp.frameHeight = 0;\n\t\n\t/** Defines named frames and frame sequences. Frame data is specified as a generic object, where each property name will \n\t* be used to define a new named frame or sequence. Named frames specify a frame number. Sequences are defined using an \n\t* array of 2 or 3 values: the start frame, the end frame, and optionally the name of the next sequence to play.<br/><br/>\n\t* For example, examine the following frame data:<br/>{walk:[0,20], shoot:[21,25,\"walk\"], crouch:[26,30,false], stand:31}<br/>\n\t* This will create 3 sequences and a named frame. The first sequence will be named \"walk\", and will loop frames 0 to 20 inclusive.\n\t* The second sequence will be named \"shoot\", and will play frames 21 to 25 then play the walk sequence. The third sequence \"crouch\" \n\t* will play frames 26 to 30 then pause on frame 30, due to false being passed as the next sequence. The named frame \"stand\" will \n\t* display frame 31.\n\t* @property frameData\n\t* @type Object\n\t**/\n\tp.frameData = null;\n\t\n\t/** The loop property is only used if no frameData is specified, and indicates whether all frames (as specified with totalFrames) \n\t* should loop. If false, the animation will play to totalFrames, then pause.\n\t* @property loop\n\t* @type Boolean\n\t**/\n\tp.loop = true;\n\t\n\t/** Specifies the total number of frames in the sprite sheet if no frameData is specified. This is useful for excluding extraneous \n\t* frames (for example, if you have 7 frames in a 2x4 sprite sheet). The total frames will be automatically calculated by \n\t* BitmapSequence based on frame and image dimensions if totalFrames is 0.\n\t* @property totalFrames\n\t* @type Number\n\t**/\n\tp.totalFrames = 0;\n\t\n// constructor:\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* param {Graphics} graphics\n\t* @protected\n\t**/\n\tp.initialize = function(image, frameWidth, frameHeight, frameData) {\n\t\tthis.image = image;\n\t\tthis.frameWidth = frameWidth;\n\t\tthis.frameHeight = frameHeight;\n\t\tthis.frameData = frameData;\n\t}\n\t\n// public methods:\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[SpriteSheet]\";\n\t}\n\t\n\t/**\n\t* Returns a clone of the SpriteSheet instance.\n\t* @method clone\n\t* @return {SpriteSheet} a clone of the SpriteSheet instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new SpriteSheet(this.image, this.frameWidth, this.frameHeight, this.frameData);\n\t\to.loop = this.loop;\n\t\to.totalFrames = this.totalFrames;\n\t\treturn o;\n\t}\n\t\nwindow.SpriteSheet = SpriteSheet;\n}(window));"},{"id" : 49, "x" : 311, "y" : 825.5, "width" : 128, "height" : 38, "nodename" : "Stage.js", "txt" : "/*\n* Stage by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\n/**\n* A stage is the root level Container for a display list. Each time its tick method is called, it will render its display\n* list to its target canvas.\n* @class Stage\n* @extends Container\n* @constructor\n* @param {HTMLCanvasElement} canvas The canvas the stage will render to.\n**/\nStage = function(canvas) {\n  this.initialize(canvas);\n}\nvar p = Stage.prototype = new Container();\n\n// static properties:\n\t/**\n\t* @property _snapToPixelEnabled\n\t* @protected\n\t* @type Boolean\n\t* @default false\n\t**/\n\tStage._snapToPixelEnabled = false; // snapToPixelEnabled is temporarily copied here during a draw to provide global access.\n\n// public properties:\n\t/** \n\t* Indicates whether the stage should automatically clear the canvas before each render. You can set this to false to manually\n\t* control clearing (for generative art, or when pointing multiple stages at the same canvas for example).\n\t* @property autoClear\n\t* @type Boolean\n\t* @default true\n\t**/\n\tp.autoClear = true;\n\t\n\t/** The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the\n\t* first stage that will be ticked (or they will clear each other's render).\n\t* @property canvas\n\t* @type HTMLCanvasElement\n\t**/\n\tp.canvas = null;\n\t\n\t/**\n\t* READ-ONLY. The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent \n\t* position over the canvas, and mouseInBounds will be set to false.\n\t* @property mouseX\n\t* @type Number\n\t* @final\n\t**/\n\tp.mouseX = null;\n\t\n\t/** READ-ONLY. The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent \n\t* position over the canvas, and mouseInBounds will be set to false.\n\t* @property mouseY\n\t* @type Number\n\t* @final\n\t**/\n\tp.mouseY = null;\n\t\n\t/** The onMouseMove callback is called when the user moves the mouse over the canvas.  The handler is passed a single param\n\t* containing the corresponding MouseEvent instance.\n\t* @event onMouseMove\n\t* @param {MouseEvent} event A MouseEvent instance with information about the current mouse event.\n\t**/\n\tp.onMouseMove = null;\n\t\n\t/**\n\t* The onMouseUp callback is called when the user releases the mouse button anywhere that the page can detect it.  The handler \n\t* is passed a single param containing the corresponding MouseEvent instance.\n\t* @event onMouseUp\n\t* @param {MouseEvent} event A MouseEvent instance with information about the current mouse event.\n\t**/\n\tp.onMouseUp = null;\n\t\n\t/**\n\t* The onMouseDown callback is called when the user presses the mouse button over the canvas.  The handler is passed a single \n\t* param containing the corresponding MouseEvent instance.\n\t* @event onMouseDown\n\t* @param {MouseEvent} event A MouseEvent instance with information about the current mouse event.\n\t**/\n\tp.onMouseDown = null;\n\n\t/**\n\t* Indicates whether this stage should use the snapToPixel property of display objects when rendering them.\n\t* @property snapToPixelEnabled\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp.snapToPixelEnabled = false;\n\t\n\t/** Indicates whether the mouse is currently within the bounds of the canvas.\n\t* @property mouseInBounds\n\t* @type Boolean\n\t* @default false\n\t**/\n\tp.mouseInBounds = false;\n\t\n// private properties:\n\n\t/**\n\t* @property _tmpCanvas\n\t* @protected\n\t* @type HTMLCanvasElement\n\t**/\n\tp._tmpCanvas = null;\n\n\t/**\n\t* @property _activeMouseEvent\n\t* @protected\n\t* @type MouseEvent\n\t**/\n\tp._activeMouseEvent = null;\n\n\t/**\n\t* @property _activeMouseTarget\n\t* @protected\n\t* @type DisplayObject\n\t**/\n\tp._activeMouseTarget = null;\n\n\t/**\n\t* @property _mouseOverIntervalID\n\t* @protected\n\t* @type Number\n\t**/\n\tp._mouseOverIntervalID = null;\n\n\t/**\n\t* @property _mouseOverX\n\t* @protected\n\t* @type Number\n\t**/\n\tp._mouseOverX = 0;\n\n\t/**\n\t* @property _mouseOverY\n\t* @protected\n\t* @type Number\n\t**/\n\tp._mouseOverY = 0;\n\n\t/**\n\t* @property _mouseOverTarget\n\t* @protected\n\t* @type DisplayObject\n\t**/\n\tp._mouseOverTarget = null;\n\t\n// constructor:\n\t/**\n\t* @property DisplayObject_initialize\n\t* @type Function\n\t* @private\n\t**/\n\tp.Container_initialize = p.initialize;\n\t\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* param {HTMLCanvasElement} canvas\n\t* @protected\n\t**/\n\tp.initialize = function(canvas) {\n\t\tthis.Container_initialize();\n\t\tthis.canvas = canvas;\n\t\tthis.mouseChildren = true;\n\t\t\n\t\tvar o = this;\n\t\tif (window.addEventListener) {\n\t\t\twindow.addEventListener(\"mouseup\", function(e) { o._handleMouseUp(e); }, false);\n\t\t\twindow.addEventListener(\"mousemove\", function(e) { o._handleMouseMove(e); }, false);\n\t\t} else if (document.addEventListener) {\n\t\t\tdocument.addEventListener(\"mouseup\", function(e) { o._handleMouseUp(e); }, false);\n\t\t\tdocument.addEventListener(\"mousemove\", function(e) { o._handleMouseMove(e); }, false);\n\t\t}\n\t\tcanvas.addEventListener(\"mousedown\", function(e) { o._handleMouseDown(e); }, false);\n\t}\n\t\n// public methods:\n\n\t/**\n\t* @event tick\n\t* Broadcast to children when the stage is updated.\n\t**/\n\n\t/**\n\t* Each time the update method is called, the stage will tick any descendants exposing a tick method (ex. BitmapSequence) \n\t* and render its entire display list to the canvas.\n\t* @method update\n\t**/\n\tp.update = function() {\n\t\tif (!this.canvas) { return; }\n\t\tif (this.autoClear) { this.clear(); }\n\t\tStage._snapToPixelEnabled = this.snapToPixelEnabled;\n\t\tthis.draw(this.canvas.getContext(\"2d\"), false, this.getConcatenatedMatrix(DisplayObject._workingMatrix));\n\t}\n\t\n\t/**\n\t* Calls the update method. Useful for adding stage as a listener to Ticker directly.\n\t* @property tick\n\t* @private\n\t* @type Function\n\t**/\n\tp.tick = p.update;\n\t\n\t/**\n\t* Clears the target canvas. Useful if autoClear is set to false.\n\t* @method clear\n\t**/\n\tp.clear = function() {\n\t\tif (!this.canvas) { return; }\n\t\tvar ctx = this.canvas.getContext(\"2d\");\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\t}\n\t\n\t/**\n\t* Returns a data url that contains a Base64 encoded image of the contents of the stage. The returned data url can be \n\t* specified as the src value of an image element.\n\t* @method toDataURL\n\t* @param {String} backgroundColor The background color to be used for the generated image. The value can be any value HTML color\n\t* value, including HEX colors, rgb and rgba. The default value is a transparent background.\n\t* @param {String} mimeType The MIME type of the image format to be create. The default is \"image/png\". If an unknown MIME type\n\t* is passed in, or if the browser does not support the specified MIME type, the default value will be used.\n\t* @return {String} a Base64 encoded image.\n\t**/\n\tp.toDataURL = function(backgroundColor, mimeType) {\n\t\tif(!mimeType) {\n\t\t\tmimeType = \"image/png\";\n\t\t}\n\n\t\tvar ctx = this.canvas.getContext('2d');\n\t\tvar w = this.canvas.width;\n\t\tvar h = this.canvas.height;\n\n\t\tvar data;\n\n\t\tif(backgroundColor) {\n\n\t\t\t//get the current ImageData for the canvas.\n\t\t\tdata = ctx.getImageData(0, 0, w, h);\n\n\t\t\t//store the current globalCompositeOperation\n\t\t\tvar compositeOperation = ctx.globalCompositeOperation;\n\n\t\t\t//set to draw behind current content\n\t\t\tctx.globalCompositeOperation = \"destination-over\";\n\n\t\t\t//set background color\n\t\t\tctx.fillStyle = backgroundColor;\n\n\t\t\t//draw background on entire canvas\n\t\t\tctx.fillRect(0, 0, w, h);\n\t\t}\n\n\t\t//get the image data from the canvas\n\t\tvar dataURL = this.canvas.toDataURL(mimeType);\n\n\t\tif(backgroundColor) {\n\t\t\t//clear the canvas\n\t\t\tctx.clearRect (0, 0, w, h);\n\n\t\t\t//restore it with original settings\n\t\t\tctx.putImageData(data, 0, 0);\n\n\t\t\t//reset the globalCompositeOperation to what it was\n\t\t\tctx.globalCompositeOperation = compositeOperation;\n\t\t}\n\n\t\treturn dataURL;\n\t}\n\n\t/**\n\t* Enables or disables (by passing a frequency of 0) mouse over handlers (onMouseOver and onMouseOut) for this stage's display\n\t* list. These events can be expensive to generate, so they are disabled by default, and the frequency of the events\n\t* can be controlled independently of mouse move events via the frequency parameter.\n\t* @method enableMouseOver\n\t* @param {Number} frequency The maximum number of times per second to broadcast mouse over/out events. Set to 0 to disable mouse\n\t* over events completely. Maximum is 50. A lower frequency is less responsive, but uses less CPU.\n\t**/\n\tp.enableMouseOver = function(frequency) {\n\t\tif (this._mouseOverIntervalID) {\n\t\t\tclearInterval(this._mouseOverIntervalID);\n\t\t\tthis._mouseOverIntervalID = null;\n\t\t}\n\t\tif (frequency <= 0) { return; }\n\t\tvar o = this;\n\t\tthis._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));\n\t\tthis._mouseOverX = NaN;\n\t\tthis._mouseOverTarget = null;\n\t}\n\t\n\t/**\n\t* Returns a clone of this Stage.\n\t* @return {Stage} A clone of the current Container instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new Stage(null);\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Stage (name=\"+  this.name +\")]\";\n\t}\n\t\n// private methods:\n\t/**\n\t* @method _handleMouseMove\n\t* @protected\n\t* @param {MouseEvent} e\n\t**/\n\tp._handleMouseMove = function(e) {\n\t\tif (!this.canvas) {\n\t\t\tthis.mouseX = this.mouseY = null;\n\t\t\treturn;\n\t\t}\n\t\tif(!e){ e = window.event; }\n\t\t\n\t\tvar inBounds = this.mouseInBounds;\n\t\tthis._updateMousePosition(e.pageX, e.pageY);\n\t\tif (!inBounds && !this.mouseInBounds) { return; }\n\n\t\tvar evt = new MouseEvent(\"onMouseMove\", this.mouseX, this.mouseY);\n\t\tif (this.onMouseMove) { this.onMouseMove(evt); }\n\t\tif (this._activeMouseEvent && this._activeMouseEvent.onMouseMove) { this._activeMouseEvent.onMouseMove(evt); }\n\t}\n\n\t/**\n\t* @method _updateMousePosition\n\t* @protected\n\t* @param {Number} pageX\n\t* @param {Number} pageY\n\t**/\n\tp._updateMousePosition = function(pageX, pageY) {\n\t\tvar o = this.canvas;\n\t\tdo {\n\t\t\tpageX -= o.offsetLeft;\n\t\t\tpageY -= o.offsetTop;\n\t\t} while (o = o.offsetParent);\n\t\t\n\t\tthis.mouseInBounds = (pageX >= 0 && pageY >= 0 && pageX < this.canvas.width && pageY < this.canvas.height);\n\n\t\tif (this.mouseInBounds) {\n\t\t\tthis.mouseX = pageX;\n\t\t\tthis.mouseY = pageY;\n\t\t}\n\t}\n\n\t/**\n\t* @method _handleMouseUp\n\t* @protected\n\t* @param {MouseEvent} e\n\t**/\n\tp._handleMouseUp = function(e) {\n\t\tvar evt = new MouseEvent(\"onMouseUp\", this.mouseX, this.mouseY);\n\t\tif (this.onMouseUp) { this.onMouseUp(evt); }\n\t\tif (this._activeMouseEvent && this._activeMouseEvent.onMouseUp) { this._activeMouseEvent.onMouseUp(evt); }\n\t\tif (this._activeMouseTarget && this._activeMouseTarget.onClick && this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true, (this._mouseOverIntervalID ? 3 : 1)) == this._activeMouseTarget) {\n\t\t\tthis._activeMouseTarget.onClick(new MouseEvent(\"onClick\", this.mouseX, this.mouseY));\n\t\t}\n\t\tthis._activeMouseEvent = this.activeMouseTarget = null;\n\t}\n\n\t/**\n\t* @method _handleMouseDown\n\t* @protected\n\t* @param {MouseEvent} e\n\t**/\n\tp._handleMouseDown = function(e) {\n\t\tif (this.onMouseDown) { this.onMouseDown(new MouseEvent(\"onMouseDown\", this.mouseX, this.mouseY)); }\n\t\tvar target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, (this._mouseOverIntervalID ? 3 : 1));\n\t\tif (target) {\n\t\t\tif (target.onPress instanceof Function) {\n\t\t\t\tvar evt = new MouseEvent(\"onPress\", this.mouseX, this.mouseY);\n\t\t\t\ttarget.onPress(evt);\n\t\t\t\tif (evt.onMouseMove || evt.onMouseUp) { this._activeMouseEvent = evt; }\n\t\t\t}\n\t\t\tthis._activeMouseTarget = target;\n\t\t}\n\t}\n\n\t/**\n\t* @method _testMouseOver\n\t* @protected\n\t**/\n\tp._testMouseOver = function() {\n\t\tif (this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds) { return; }\n\t\tvar target = null;\n\t\tif (this.mouseInBounds) {\n\t\t\tvar target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3);\n\t\t\tthis._mouseOverX = this.mouseX;\n\t\t\tthis._mouseOverY = this.mouseY;\n\t\t}\n\t\tif (this._mouseOverTarget != target) {\n\t\t\tif (this._mouseOverTarget && this._mouseOverTarget.onMouseOut) {\n\t\t\t\tthis._mouseOverTarget.onMouseOut(new MouseEvent(\"onMouseOver\", this.mouseX, this.mouseY));\n\t\t\t}\n\t\t\tif (target && target.onMouseOver) {\n\t\t\t\ttarget.onMouseOver(new MouseEvent(\"onMouseOut\", this.mouseX, this.mouseY));\n\t\t\t}\n\t\t\tthis._mouseOverTarget = target;\n\t\t}\n\t}\n\nwindow.Stage = Stage;\n}(window));"},{"id" : 50, "x" : 311, "y" : 882.5, "width" : 127, "height" : 39, "nodename" : "Text.js", "txt" : "/*\n* Text by Grant Skinner. Dec 5, 2010\n* Visit http://easeljs.com/ for documentation, updates and examples.\n*\n*\n* Copyright (c) 2010 Grant Skinner\n* \n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n* \n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* The Easel Javascript library provides a retained graphics mode for canvas \n* including a full, hierarchical display list, a core interaction model, and \n* helper classes to make working with Canvas much easier.\n* @module EaselJS\n**/\n\n(function(window) {\n\t\n/**\n* Allows you to display one or more lines of dynamic text (not user editable) in the display list.\n* Line wrapping support (using the lineWidth is very basic, wrapping on spaces and tabs only. Note\n* that as an alternative to Text, you can position HTML text above or below the canvas relative to \n* items in the display list using the localToGlobal() method.\n* @class Text\n* @extends DisplayObject\n* @constructor\n* @param {String} text Optional. The text to display.\n* @param {String} font Optional. The font style to use. Any valid value for the CSS font attribute is \n* acceptable (ex. \"36px bold Arial\").\n* @param {String} color Optional. The color to draw the text in. Any valid value for the CSS color attribute\n* is acceptable (ex. \"#F00\").\n**/\nText = function(text, font, color) {\n  this.initialize(text, font, color);\n}\n\nvar p = Text.prototype = new DisplayObject();\n\n\n/**\n* @property _workingContext\n* @type CanvasRenderingContext2D\n* @private \n**/\nText._workingContext = document.createElement(\"canvas\").getContext(\"2d\");\n\n// public properties:\n\t/**\n\t* The text to display.\n\t* @property text\n\t* @type String\n\t**/\n\tp.text = \"\";\n\t\n\t/**\n\t* The font style to use. Any valid value for the CSS font attribute is acceptable (ex. \"bold 36px Arial\"). \n\t* @property font\n\t* @type String\n\t**/\n\tp.font = null;\n\t\n\t/**\n\t* The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. \"#F00\").\n\t* @property color\n\t* @type String\n\t**/\n\tp.color = null;\n\t\n\t/**\n\t* The horizontal text alignment. Any of \"start\", \"end\", \"left\", \"right\", and \"center\". For detailed \n\t* information view the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-0\">\n\t* whatwg spec</a>.\n\t* @property textAlign\n\t* @type String\n\t**/\n\tp.textAlign = null;\n\t\n\t/** The vertical alignment point on the font. Any of \"top\", \"hanging\", \"middle\", \"alphabetic\", \n\t* \"ideographic\", or \"bottom\". For detailed information view the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-0\">\n\t* whatwg spec</a>.\n\t* @property textBaseline\n\t* @type String\n\t*/\n\tp.textBaseline = null;\n\t\n\t/** The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or \n\t* shrunk to make it fit in this width. For detailed information view the \n\t* <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-0\">\n\t* whatwg spec</a>.\n\t* @property maxWidth\n\t* @type Number\n\t*/\n\tp.maxWidth = null;\n\t\n\t/** If true, the text will be drawn as a stroke (outline). If false, the text will be drawn as a fill.\n\t* @property outline\n\t* @type Boolean\n\t**/\n\tp.outline = false;\n\t\n\t/** Indicates the line height (vertical distance between baselines) for multi-line text. If null, \n\t* the value of getMeasuredLineHeight is used.\n\t* @property lineHeight\n\t* @type Number\n\t**/\n\tp.lineHeight = null;\n\t\n\t/**\n\t* Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null, \n\t* the text will not be wrapped.\n\t* @property lineWidth\n\t* @type Number\n\t**/\n\tp.lineWidth = null;\n\t\n// constructor:\n\t/**\n\t* @property DisplayObject_initialize\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_initialize = p.initialize;\n\t\n\t/** \n\t* Initialization method.\n\t* @method initialize\n\t* @protected\n\t*/\n\tp.initialize = function(text, font, color) {\n\t\tthis.DisplayObject_initialize();\n\t\tthis.text = text;\n\t\tthis.font = font;\n\t\tthis.color = color ? color : \"#000\";\n\t}\n\t\n\t/**\n\t* Returns true or false indicating whether the display object would be visible if drawn to a canvas.\n\t* This does not account for whether it would be visible within the boundaries of the stage.\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method isVisible\n\t* @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas\n\t**/\n\tp.isVisible = function() {\n\t\treturn Boolean(this.visible && this.alpha > 0 && \n\t\t\t\t\t\tthis.scaleX != 0 && this.scaleY != 0 && this.text != null && this.text != \"\");\n\t}\n\n\t/**\n\t* @property DisplayObject_draw\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_draw = p.draw;\n\t\n\t/**\n\t* Draws the Text into the specified context ignoring it's visible, alpha, shadow, and transform.\n\t* Returns true if the draw was handled (useful for overriding functionality).\n\t* NOTE: This method is mainly for internal use, though it may be useful for advanced uses.\n\t* @method draw\n\t* @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.\n\t* @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache. \n\t* For example, used for drawing the cache (to prevent it from simply drawing an existing cache back\n\t* into itself).\n\t**/\n\tp.draw = function(ctx, ignoreCache) {\n\t\tif (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }\n\t\t\n\t\tif (this.outline) { ctx.strokeStyle = this.color; }\n\t\telse { ctx.fillStyle = this.color; }\n\t\tctx.font = this.font;\n\t\tctx.textAlign = this.textAlign ? this.textAlign : \"start\";\n\t\tctx.textBaseline = this.textBaseline ? this.textBaseline : \"alphabetic\";\n\n\t\tvar lines = String(this.text).split(/(?:\\r\\n|\\r|\\n)/);\n\t\tvar lineHeight = (this.lineHeight == null) ? this.getMeasuredLineHeight() : this.lineHeight;\n\t\tvar y = 0;\n\t\tfor (var i=0, l=lines.length; i<l; i++) {\n\t\t\tvar w = ctx.measureText(lines[i]).width;\n\t\t\tif (this.lineWidth == null || w < this.lineWidth) {\n\t\t\t\tthis._drawTextLine(ctx, lines[i], y);\n\t\t\t\ty += lineHeight;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// split up the line\n\t\t\tvar words = lines[i].split(/(\\s)/);\n\t\t\tvar str = words[0];\n\t\t\tfor (var j=1, jl=words.length; j<jl; j+=2) {\n\t\t\t\t// Line needs to wrap:\n\t\t\t\tif (ctx.measureText(str + words[j] + words[j+1]).width > this.lineWidth) {\n\t\t\t\t\tthis._drawTextLine(ctx, str, y);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t\tstr = words[j+1];\n\t\t\t\t} else {\n\t\t\t\t\tstr += words[j] + words[j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._drawTextLine(ctx, str, y); // Draw remaining text\n\t\t\ty += lineHeight;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/**\n\t* Returns the measured, untransformed width of the text.\n\t* @method getMeasuredWidth\n\t* @return {Number} The measured, untransformed width of the text.\n\t**/\n\tp.getMeasuredWidth = function() {\n\t\treturn this._getWorkingContext().measureText(this.text).width;\n\t}\n\n\t/**\n\t* Returns an approximate line height of the text, ignoring the lineHeight property. This is based \n\t* on the measured width of a \"M\" character multiplied by 1.2, which approximates em for most fonts.\n\t* @method getMeasuredLineHeight\n\t* @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is \n\t* based on the measured width of a \"M\" character multiplied by 1.2, which approximates em for most fonts.\n\t**/\n\tp.getMeasuredLineHeight = function() {\n\t\treturn this._getWorkingContext().measureText(\"M\").width*1.2;\n\t}\n\t\n\t/**\n\t* Returns a clone of the Point instance.\n\t* @method clone\n\t* @return {Point} a clone of the Point instance.\n\t**/\n\tp.clone = function() {\n\t\tvar o = new Text(this.text, this.font, this.color);\n\t\tthis.cloneProps(o);\n\t\treturn o;\n\t}\n\t\t\n\t/**\n\t* Returns a string representation of this object.\n\t* @method toString\n\t* @return {String} a string representation of the instance.\n\t**/\n\tp.toString = function() {\n\t\treturn \"[Text (text=\"+  (this.text.length > 20 ? this.text.substr(0, 17)+\"...\" : this.text) +\")]\";\n\t}\n\t\n// private methods:\n\t\n\t/**\n\t* @property DisplayObject_cloneProps\n\t* @private\n\t* @type Function\n\t**/\n\tp.DisplayObject_cloneProps = p.cloneProps;\n\n\t/** \n\t * @method cloneProps\n\t * @param {Text} o\n\t * @protected \n\t **/\n\tp.cloneProps = function(o) {\n\t\tthis.DisplayObject_cloneProps(o);\n\t\to.textAlign = this.textAlign;\n\t\to.textBaseline = this.textBaseline;\n\t\to.maxWidth = this.maxWidth;\n\t\to.outline = this.outline;\n\t\to.lineHeight = this.lineHeight;\n\t\to.lineWidth = this.lineWidth;\n\t}\n\n\t/** \n\t * @method _getWorkingContext\n\t * @protected \n\t **/\n\tp._getWorkingContext = function() {\n\t\tvar ctx = Text._workingContext;\n\t\tctx.font = this.font;\n\t\tctx.textAlign = this.textAlign ? this.textAlign : \"start\";\n\t\tctx.textBaseline = this.textBaseline ? this.textBaseline : \"alphabetic\";\n\t\treturn ctx;\n\t}\n\t\n\t/** \n\t * @method _drawTextLine\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {Text} text\n\t * @param {Number} y\n\t * @protected \n\t **/\n\tp._drawTextLine = function(ctx, text, y) {\n\t\tif (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth); }\n\t\telse { ctx.fillText(text, 0, y, this.maxWidth); }\n\t}\n\nwindow.Text = Text;\n}(window));"}], "connections" : [{"nodeA" : 0, "nodeB" : 1, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 2, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 3, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 4, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 5, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 6, "conA" : "bottom", "conB" : "top"},{"nodeA" : 0, "nodeB" : 7, "conA" : "bottom", "conB" : "top"},{"nodeA" : 3, "nodeB" : 8, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 10, "conA" : "bottom", "conB" : "top"},{"nodeA" : 10, "nodeB" : 11, "conA" : "bottom", "conB" : "top"},{"nodeA" : 10, "nodeB" : 12, "conA" : "bottom", "conB" : "top"},{"nodeA" : 10, "nodeB" : 13, "conA" : "bottom", "conB" : "top"},{"nodeA" : 10, "nodeB" : 14, "conA" : "bottom", "conB" : "top"},{"nodeA" : 3, "nodeB" : 9, "conA" : "bottom", "conB" : "top"},{"nodeA" : 12, "nodeB" : 25, "conA" : "bottom", "conB" : "left"},{"nodeA" : 13, "nodeB" : 26, "conA" : "bottom", "conB" : "left"},{"nodeA" : 13, "nodeB" : 27, "conA" : "bottom", "conB" : "left"},{"nodeA" : 13, "nodeB" : 28, "conA" : "bottom", "conB" : "left"},{"nodeA" : 14, "nodeB" : 29, "conA" : "bottom", "conB" : "left"},{"nodeA" : 14, "nodeB" : 30, "conA" : "bottom", "conB" : "left"},{"nodeA" : 14, "nodeB" : 31, "conA" : "bottom", "conB" : "left"},{"nodeA" : 7, "nodeB" : 32, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 33, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 34, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 35, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 36, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 37, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 38, "conA" : "bottom", "conB" : "top"},{"nodeA" : 7, "nodeB" : 39, "conA" : "bottom", "conB" : "top"},{"nodeA" : 11, "nodeB" : 41, "conA" : "bottom", "conB" : "left"},{"nodeA" : 43, "nodeB" : 42, "conA" : "bottom", "conB" : "bottom"},{"nodeA" : 43, "nodeB" : 42, "conA" : "bottom", "conB" : "bottom"},{"nodeA" : 11, "nodeB" : 43, "conA" : "bottom", "conB" : "left"},{"nodeA" : 45, "nodeB" : 44, "conA" : "bottom", "conB" : "bottom"},{"nodeA" : 45, "nodeB" : 44, "conA" : "bottom", "conB" : "bottom"},{"nodeA" : 11, "nodeB" : 45, "conA" : "bottom", "conB" : "left"},{"nodeA" : 11, "nodeB" : 46, "conA" : "bottom", "conB" : "left"},{"nodeA" : 11, "nodeB" : 47, "conA" : "bottom", "conB" : "left"},{"nodeA" : 11, "nodeB" : 48, "conA" : "bottom", "conB" : "left"},{"nodeA" : 11, "nodeB" : 49, "conA" : "bottom", "conB" : "left"},{"nodeA" : 11, "nodeB" : 50, "conA" : "bottom", "conB" : "left"}]}